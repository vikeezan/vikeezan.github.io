<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>十大经典排序算法</title>
    <url>/2019/07/28/10-algorithms/</url>
    <content><![CDATA[<h2 id="0-算法概述"><a href="#0-算法概述" class="headerlink" title="0.算法概述"></a><table><tr><td bgcolor=Gold><font size=5>0.算法概述</font></td></tr></table></h2><h3 id="0-1算法分类"><a href="#0-1算法分类" class="headerlink" title="0.1算法分类"></a>0.1算法分类</h3><p>十种常见的排序算法可以分为两大类：</p>
<ul>
<li><font color=#DC143C>比较类排序：</font>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li>
<li><font color=#DC143C>非比较类排序：</font>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。<span id="more"></span>
<img src="/2019/07/28/10-algorithms/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.jpg" class="" title="排序算法分类"></li>
</ul>
<h3 id="0-2算法时间复杂度比较"><a href="#0-2算法时间复杂度比较" class="headerlink" title="0.2算法时间复杂度比较"></a>0.2算法时间复杂度比较</h3><p>不同的算法在时间和空间上的复杂度各不相同，一般来说，算法所需要的运算空间越小，时间越短，则表明该算法更优。<br>本文涉及的十种经典算法的复杂度如下:</p>
<img src="/2019/07/28/10-algorithms/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.png" class="" title="十大经典算法复杂度">

<h3 id="0-3算法中的相关概念"><a href="#0-3算法中的相关概念" class="headerlink" title="0.3算法中的相关概念"></a>0.3算法中的相关概念</h3><ul>
<li><b>稳定性：</b> 在a&#x3D;b的情况下，a原本排在b之前，若算法稳定的话，排序之后a依旧在b之前；若算法不稳定，排序之后a可能会出现在b之后。</li>
<li><b>时间复杂度：</b> 指算法对排序数据的总的操作次数。反映当数据个数的n变化时，其操作次数的增减规律。</li>
<li><b>空间复杂度：</b> 指算法在计算机内执行所需的存储空间。反映其随着数据个数n变化的增减规律。</li>
</ul>
<h2 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a><table><tr><td bgcolor=Gold><font size=5>1.冒泡排序（Bubble Sort）</font></td></tr></table></h2><p>冒泡排序的基本思想是：重复比较相邻的两个元素，若顺序错误就将它们的位置交换，直到被排序的所有元素不再需要交换位置时，表明该数列已经排序完成。该算法的名字由来是因为越小的元素会随着排序的进行慢慢“漂浮（冒泡）”到数列的顶端。</p>
<h3 id="1-1算法步骤"><a href="#1-1算法步骤" class="headerlink" title="1.1算法步骤"></a>1.1算法步骤</h3><ul>
<li>比较相邻的两个元素。若第一个比第二个大，则交换位置，将小元素放在前面；</li>
<li>对每一对相邻的元素都执行相同的操作，从开始第一对到最后一对，排序之后，最后一个元素应该是最大的数；</li>
<li>除去最后一个元素，针对所有元素重复1、2两步；</li>
<li>重复1~3步，直到排序完成。<img src="/2019/07/28/10-algorithms/1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" class="" title="冒泡排序"></li>
</ul>
<h3 id="1-2代码实现"><a href="#1-2代码实现" class="headerlink" title="1.2代码实现"></a>1.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比</span><br><span class="line">                var temp = arr[j+1];        // 元素交换</span><br><span class="line">                arr[j+1] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a><table><tr><td bgcolor=Gold><font size=5>2.选择排序（Selection Sort）</font></td></tr></table></h2><p>选择排序是一种简单直观的排序算法。基本思想是：首先在未排序序列中找到最小（大）的元素，存放到排序序列的起始位置，然后再从剩余的未排序元素中选出最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素都被选择完。</p>
<h3 id="2-1算法步骤"><a href="#2-1算法步骤" class="headerlink" title="2.1算法步骤"></a>2.1算法步骤</h3><p>假设有n个数据，那么可以通过n-1次直接选择排序得到有序结果。具体的算法如下：</p>
<ul>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i&#x3D;1,2,3…n-1)：排序之前的有序区为R[1..i-1]，无序区为R(i..n）。该趟排序从无序区中选择出关键字最小的记录R[k]，将它与无序区的第1个记录R交换，排序之后的新有序区为R[1..i]，新无序区为R[i+1..n]；</li>
<li>n-1次排序结束，数组最终排序完成。<img src="/2019/07/28/10-algorithms/2.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" class="" title="选择排序"></li>
</ul>
<h3 id="2-2代码实现"><a href="#2-2代码实现" class="headerlink" title="2.2代码实现"></a>2.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数</span><br><span class="line">                minIndex = j;                 // 将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3算法分析"><a href="#2-3算法分析" class="headerlink" title="2.3算法分析"></a>2.3算法分析</h3><p>该算法表现非常稳定，是最稳定的排序算法之一。因为无论什么数据进去都是O(n2)的时间复杂度，所以使用该算法时，数据规模越小越好。好处在于不占用额外的内存空间。理论上讲，选择排序可能是能被最多人想到的排序算法。</p>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a><table><tr><td bgcolor=Gold><font size=5>3.插入排序（Insertion Sort）</font></td></tr></table></h2><p>插入排序是一种简单直观的排序算法。基本思想是：通过构建有序数列，对于未排序的数据，在已排序的序列中从后向前扫描，找到相应位置并插入。</p>
<h3 id="3-1算法步骤"><a href="#3-1算法步骤" class="headerlink" title="3.1算法步骤"></a>3.1算法步骤</h3><p>一般来说，插入排序采用in-place在数组上实现。具体的算法如下：</p>
<ul>
<li>第一个元素可以视为已经被排序；</li>
<li>取出下一个元素，在已排序的元素序列中，从后向前扫描；</li>
<li>若已排序数列中的旧元素大于新元素，则将旧元素移到下一个位置；</li>
<li>重复步骤3，直到找到已排序数列中的旧元素小于或等于新元素的位置；</li>
<li>将新元素插入该位置；</li>
<li>重复步骤2~5。<img src="/2019/07/28/10-algorithms/3.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" class="" title="插入排序"></li>
</ul>
<h3 id="3-2代码实现"><a href="#3-2代码实现" class="headerlink" title="3.2代码实现"></a>3.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function insertionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var preIndex, current;</span><br><span class="line">    for (var i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - 1;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + 1] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + 1] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3算法分析"><a href="#3-3算法分析" class="headerlink" title="3.3算法分析"></a>3.3算法分析</h3><p>插入算法在实现上通常使用in-place排序，所以只需要O(1)的额外空间，因而在从后向前扫描的过程中，需要反复把已排序元素逐步向后移动位置，为新元素提供插入空间。</p>
<h2 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a><table><tr><td bgcolor=Gold><font size=5>4.希尔排序（Shell Sort）</font></td></tr></table></h2><p>1959年由Shell发明,是第一个突破O(n2)的排序算法，是插入排序的改进版。它和插入排序的不同之处在于，它会优先比较距离较远的元素。所以希尔排序又叫做缩小增量排序。</p>
<h3 id="4-1算法步骤"><a href="#4-1算法步骤" class="headerlink" title="4.1算法步骤"></a>4.1算法步骤</h3><p>将整个待排序的序列分割称为若干子序列，分别进行直接插入排序，具体的算法如下：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li>
<li>按增量序列个数k，对序列进行k次排序；</li>
<li>每次排序根据对应的增量ti，将待排序的数列分割为若干长度为m的子序列，分别对子序列进行直接插入排序。只有当增量因子变为1时，将整个数列作为一整个序列来处理，序列长度即为整个数列的长度。<img src="/2019/07/28/10-algorithms/4.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" class="" title="希尔排序"></li>
</ul>
<h3 id="4-2代码实现"><a href="#4-2代码实现" class="headerlink" title="4.2代码实现"></a>4.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function shellSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) &#123;</span><br><span class="line">        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span><br><span class="line">        for (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            var j = i;</span><br><span class="line">            var current = arr[i];</span><br><span class="line">            while (j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                 arr[j] = arr[j - gap];</span><br><span class="line">                 j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3算法分析"><a href="#4-3算法分析" class="headerlink" title="4.3算法分析"></a>4.3算法分析</h3><p>希尔序列的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法出自《算法（第4版）》。</p>
<h2 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a><table><tr><td bgcolor=Gold><font size=5>5.归并排序（Merge Sort）</font></td></tr></table></h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是分治法（Divide and Conquer）的一个典型的应用。基本思想是：将已有的子序列合并，得到完全有序的序列。即先让每个子序列有序，再使得子序列段间有序。若将两个有序表合并成为一个有序表，则可以称作2路归并。</p>
<h3 id="5-1算法步骤"><a href="#5-1算法步骤" class="headerlink" title="5.1算法步骤"></a>5.1算法步骤</h3><ul>
<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成为一个最终的有序的序列。<img src="/2019/07/28/10-algorithms/5.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" class="" title="归并排序"></li>
</ul>
<h3 id="5-2代码实现"><a href="#5-2代码实现" class="headerlink" title="5.2代码实现"></a>5.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mergeSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    if (len &lt; 2) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle = Math.floor(len / 2),</span><br><span class="line">        left = arr.slice(0, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function merge(left, right) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line"></span><br><span class="line">    while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123;</span><br><span class="line">        if (left[0] &lt;= right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"></span><br><span class="line">    while (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-算法分析"><a href="#5-3-算法分析" class="headerlink" title="5.3 算法分析"></a>5.3 算法分析</h3><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但是表现比选择排序要好得多，因为时间复杂度始终为O(nlogn）。代价是需要额外的内存空间。</p>
<h2 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a><table><tr><td bgcolor=Gold><font size=5>6.快速排序（Quick Sort）</font></td></tr></table></h2><p>快速排序的基本思想是：通过一趟排序将待排序的数据分割成为独立的两部分。其中一个部分记录的数据均比另一个部分的数据小，那么可以分别对这两部分的数据继续进行排序，从而达到整个序列有序的目的。</p>
<h3 id="6-1算法步骤"><a href="#6-1算法步骤" class="headerlink" title="6.1算法步骤"></a>6.1算法步骤</h3><p>快速排序使用分治法把一个串(list)分成两个子串(sub-lists)。具体的算法如下：</p>
<ul>
<li>从数列中挑出一个元素，称为“基准”(pivot);</li>
<li>重新排序数列，将数列中比基准值小的数据放在基准前面，比基准值大的数据放在基准后面（相同的数据可以放到任意一边）。在该分区退出之后，该基准就处于数列的中间位置。这个操作称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。<img src="/2019/07/28/10-algorithms/6.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" class="" title="快速排序"></li>
</ul>
<h3 id="6-2代码实现"><a href="#6-2代码实现" class="headerlink" title="6.2代码实现"></a>6.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function quickSort(arr, left, right) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left = typeof left != &#x27;number&#x27; ? 0 : left,</span><br><span class="line">        right = typeof right != &#x27;number&#x27; ? len - 1 : right;</span><br><span class="line"></span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex-1);</span><br><span class="line">        quickSort(arr, partitionIndex+1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function partition(arr, left ,right) &#123;     // 分区操作</span><br><span class="line">    var pivot = left,                      // 设定基准值（pivot）</span><br><span class="line">        index = pivot + 1;</span><br><span class="line">    for (var i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        if (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - 1);</span><br><span class="line">    return index-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a><table><tr><td bgcolor=Gold><font size=5>7.堆排序（Heap Sort）</font></td></tr></table></h2><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（大于）它的父节点。</p>
<h3 id="7-1算法步骤"><a href="#7-1算法步骤" class="headerlink" title="7.1算法步骤"></a>7.1算法步骤</h3><ul>
<li>将初始待排序数列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时新无序区为(R1,R2,……Rn-1)，新有序区为(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此将当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新无序区为(R1,R2….Rn-2)，新有序区为(Rn-1,Rn)。</li>
<li>不断重复此过程，直到有序区元素个数为n-1，则整个排序过程完成。<img src="/2019/07/28/10-algorithms/7.%E5%A0%86%E6%8E%92%E5%BA%8F.gif" class="" title="堆排序"></li>
</ul>
<h3 id="7-2代码实现"><a href="#7-2代码实现" class="headerlink" title="7.2代码实现"></a>7.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br><span class="line"></span><br><span class="line">function buildMaxHeap(arr) &#123;   // 建立大顶堆</span><br><span class="line">    len = arr.length;</span><br><span class="line">    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function heapify(arr, i) &#123;     // 堆调整</span><br><span class="line">    var left = 2 * i + 1,</span><br><span class="line">        right = 2 * i + 2,</span><br><span class="line">        largest = i;</span><br><span class="line"></span><br><span class="line">    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (largest != i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function heapSort(arr) &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"></span><br><span class="line">    for (var i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(arr, 0, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a><table><tr><td bgcolor=Gold><font size=5>8.计数排序（Counting Sort）</font></td></tr></table></h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是<strong>有确定范围的整数</strong>。</p>
<h3 id="8-1算法步骤"><a href="#8-1算法步骤" class="headerlink" title="8.1算法步骤"></a>8.1算法步骤</h3><ul>
<li>找出待排序数组中的最大和最小元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<img src="/2019/07/28/10-algorithms/8.%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" class="" title="计数排序"></li>
</ul>
<h3 id="8-2代码实现"><a href="#8-2代码实现" class="headerlink" title="8.2代码实现"></a>8.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function countingSort(arr, maxValue) &#123;</span><br><span class="line">    var bucket = new Array(maxValue + 1),</span><br><span class="line">        sortedIndex = 0;</span><br><span class="line">        arrLen = arr.length,</span><br><span class="line">        bucketLen = maxValue + 1;</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; arrLen; i++) &#123;</span><br><span class="line">        if (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var j = 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        while(bucket[j] &gt; 0) &#123;</span><br><span class="line">            arr[sortedIndex++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3算法分析"><a href="#8-3算法分析" class="headerlink" title="8.3算法分析"></a>8.3算法分析</h3><p>计数算法是一个稳定的排序算法。当输入的元素是n个0到k之间的整数时，时间复杂度为O(n+k)，空间复杂度也是O(n+k)，它的排序速度快于任何比较排序算法。当k不是很大且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a><table><tr><td bgcolor=Gold><font size=5>9.桶排序（Bucket Sort）</font></td></tr></table></h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键在于这个映射函数。基本思想是：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<h3 id="9-1算法步骤"><a href="#9-1算法步骤" class="headerlink" title="9.1算法步骤"></a>9.1算法步骤</h3><ul>
<li>设定一个定量的数组当做空桶；</li>
<li>遍历输入数据，并且把数据一个个放到对应的桶中；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把已排序的数据拼接起来。<img src="/2019/07/28/10-algorithms/9.%E6%A1%B6%E6%8E%92%E5%BA%8F.png" class="" title="桶排序"></li>
</ul>
<h3 id="9-2代码实现"><a href="#9-2代码实现" class="headerlink" title="9.2代码实现"></a>9.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length === 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var i;</span><br><span class="line">    var minValue = arr[0];</span><br><span class="line">    var maxValue = arr[0];</span><br><span class="line">    for (i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                // 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                // 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5</span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;</span><br><span class="line">    var buckets = new Array(bucketCount);</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr.length = 0;</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j = 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3算法分析"><a href="#9-3算法分析" class="headerlink" title="9.3算法分析"></a>9.3算法分析</h3><p>桶排序最好情况下的时间复杂度为O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。缺点是相应的空间消耗就会增大。</p>
<h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a><table><tr><td bgcolor=Gold><font size=5>10.基数排序（Radix Sort）</font></td></tr></table></h2><p>基数排序是按照数列的低位先排序（例如个位），然后收集；再按照数列的高位排序（例如十位），然后再收集；以此类推，直到最高位。有时候有些属性有优先级顺序，先按低优先级排序，再按高优先级排序。最后的结果就是高优先级在前，高优先级相同的话则低优先级高的在前。</p>
<h3 id="10-1算法步骤"><a href="#10-1算法步骤" class="headerlink" title="10.1算法步骤"></a>10.1算法步骤</h3><ul>
<li>取得数组中的最大数，并且取得数组的位数；</li>
<li>arr为原始数组，从最低位开始每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）。<img src="/2019/07/28/10-algorithms/10.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" class="" title="基数排序"></li>
</ul>
<h3 id="10-2代码实现"><a href="#10-2代码实现" class="headerlink" title="10.2代码实现"></a>10.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var counter = [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod = 10;</span><br><span class="line">    var dev = 1;</span><br><span class="line">    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</span><br><span class="line">        for(var j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">            if(counter[bucket]==null) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = 0;</span><br><span class="line">        for(var j = 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value = null;</span><br><span class="line">            if(counter[j]!=null) &#123;</span><br><span class="line">                while ((value = counter[j].shift()) != null) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-3算法分析"><a href="#10-3算法分析" class="headerlink" title="10.3算法分析"></a>10.3算法分析</h3><p>1.基数排序是分别排序，分别收集，所以总体上是稳定的。不过基数排序的性能比桶排序差一点，每一次数据的桶分配都需要O(n)的时间复杂度，且分配之后得到的新的数据序列又需要O(n)的时间复杂度。假如待排序的数据可以分为d组，那么基数排序的时间复杂度将是O(d*2n)，当然d要远远小于n，因此基本上还是线性级别的。<br>2.基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo多终端管理的搭建流程</title>
    <url>/2019/03/27/Multi-terminal-management/</url>
    <content><![CDATA[<h2 id="1-原理介绍"><a href="#1-原理介绍" class="headerlink" title="1.原理介绍"></a>1.原理介绍</h2><p>多终端管理的基本思路是将博客在Github网站上分为两个分支来管理：</p>
<ul>
<li>一个是master主分支用于存放博客的静态网站文件（<code>hexo server</code>之后会在本地文件里生成public文件夹，public文件夹内是根据.md生成的html静态网站文件），我们在电脑上更新完博客之后可以<code>hexo deploy</code>到该分支上，平时点进你的网站<a href="https://username.github.io/">https://username.github.io/</a>时看到的内容就是这个分支解析出来的。<span id="more"></span></li>
<li>另一个分支则是hexo副分支（自己起的名字，可以更改），这个分支的作用是保存博客的最新版本，在不同的电脑上pull并新建博客后，push到这个分支上，这样随时都可以找到博客的最新版本，该分支上的更改如果不经过<code>hexo deploy</code>，不会影响到master主分支上的内容。</li>
</ul>
<p><strong>PS：个人建议之前没有接触过git的同学可以先看一下有关git的基础教程，因为没接触过git的同学瞎用指令会把网站搞崩的，别问我为啥知道…这里推荐廖雪峰的课</strong><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰git教程</a></p>
<h2 id="2-搭建流程"><a href="#2-搭建流程" class="headerlink" title="2.搭建流程"></a>2.搭建流程</h2><p>1.创建仓库，<a href="https://username.github.io/">https://username.github.io/</a>。其中的<strong>username</strong>要由你自己定义，要和你Github注册的用户名保持一致;<br>2.创建两个分支，master和hexo。这一步不用手动创建，后面有指令会自动创建hexo分支的；<br>3.设置hexo为默认分支。因为我们只需要手动管理这个分支上的网站文件，设置方法为项目右上角setting里的branch选项卡，将其中的默认分支更改为hexo即可；<br>4.在第二台电脑上使用git clone <a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#111;&#109;">&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#111;&#109;</a>:username&#x2F;username.github.io.git拷贝仓库；<br>5.在本地的与Github相连的<a href="https://username.github.io/">https://username.github.io/</a>文件夹下右键使用Git Bash依次执行<code>npm install -g hexo-cli </code>安装hexo、<code>hexo init</code>初始化hexo、<code>npm install hexo-deployer-git --save</code>让hexo知道你要把blog部署在哪一个位置。这三条指令完成后当前分支应显示为hexo；<br>6.修改博客站点配置文件<code>_config.yml</code>中的deploy参数，将branch的参数改为master；<br>7.依次执行<code>git add .</code>添加所有文件到缓存区、<code>git commit -m “…”</code>提交缓存区的文件同时增添备注、<code>git push origin hexo</code>将更改的内容push到github的hexo分支进行备份；<br>8.执行<code>hexo g -d</code>生成网站并部署到Github上。<br>经过以上操作之后，我们的master分支用于存放网站的静态文件，hexo分支用于存放网站的原始文件，井水不犯河水，简直太完美了有没有！</p>
<h3 id="2-1第一个终端的hexo分支"><a href="#2-1第一个终端的hexo分支" class="headerlink" title="2.1第一个终端的hexo分支"></a>2.1第一个终端的hexo分支</h3><p>在一开始创建博客的电脑上，将本地blog文件夹内必要的hexo文件push到username.github.io的hexo分支上，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init  //初始化本地仓库</span><br><span class="line">git add source //将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件,例如source themes scaffolds _config.yml package.json package-lock.json等。</span><br><span class="line">git commit -m &quot;Blog Source Hexo&quot; //备注这是blog网站最原始的文件</span><br><span class="line">git branch hexo  //新建hexo分支</span><br><span class="line">git checkout hexo  //切换到hexo分支上</span><br><span class="line">git remote add origin git@github.com:yourname/yourname.github.io.git  //将本地与Github项目对接</span><br><span class="line">git push origin hexo  //push到Github项目的hexo分支上</span><br></pre></td></tr></table></figure>
<h3 id="2-2另一终端完成clone复制以及push更新"><a href="#2-2另一终端完成clone复制以及push更新" class="headerlink" title="2.2另一终端完成clone复制以及push更新"></a>2.2另一终端完成clone复制以及push更新</h3><p>在另一个终端更新博客，只需要将Github的hexo分支上的内容克隆到本地，然后再对其进行更改和push更新，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b hexo git@github.com:yourname/yourname.github.io.git  //将Github中hexo分支clone到本地</span><br><span class="line">cd  yourname.github.io  //切换到刚刚clone的文件夹内</span><br><span class="line">npm install -g hexo-cli    //注意！一定要切换到刚刚clone的文件夹内执行，安装hexo</span><br><span class="line">npm install hexo-deployer-git --save //让hexo知道你要把blog部署在哪一个位置</span><br><span class="line">hexo new post &quot;new blog name&quot;   //新建博客并编辑内容</span><br><span class="line">git add source  //经测试每次只要更新source中的文件到Github中即可，因为只是新建了一篇新博客</span><br><span class="line">git commit -m &quot;XX&quot; //对本次修改进行备注</span><br><span class="line">git push origin hexo  //将当前终端的文件更新到Github上的hexo分支上</span><br><span class="line">hexo d -g   //将自己写的博客部署到自己的博客网站上，同时同步Github中的master分支</span><br></pre></td></tr></table></figure>
<h2 id="3-日常的修改流程"><a href="#3-日常的修改流程" class="headerlink" title="3.日常的修改流程"></a>3.日常的修改流程</h2><p>先对本地的博客进行修改，例如增加博客，更改样式等，再将新的内容push到Github的hexo分支上，哭啼的操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin hexo  //先pull云端的hexo分支文件，完成本地与远端的融合</span><br><span class="line">hexo new post &quot; new blog name&quot; //新建博客并编辑内容</span><br><span class="line">git add source</span><br><span class="line">git commit -m &quot;XX&quot;</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>

<p>本文的参考链接：<a href="https://blog.csdn.net/ZmeiXuan/article/details/78339376">https://blog.csdn.net/ZmeiXuan/article/details/78339376</a></p>
]]></content>
      <categories>
        <category>建站填坑</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>多终端搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>菜鸟教程-Java教程-学习笔记</title>
    <url>/2024/10/16/cainiao-java-learning/</url>
    <content><![CDATA[<p>此文档仅基于个人经验和感受出发，为菜鸟驿站-java教程的学习笔记。</p>
<p>课程参考链接：<a href="https://www.runoob.com/java/java-tutorial.html">https://www.runoob.com/java/java-tutorial.html</a></p>
<span id="more"></span>

<h2 id="一、Java基础语法-amp-Java注释"><a href="#一、Java基础语法-amp-Java注释" class="headerlink" title="一、Java基础语法&amp;Java注释"></a>一、Java基础语法&amp;Java注释</h2><h3 id="1、Java修饰符"><a href="#1、Java修饰符" class="headerlink" title="1、Java修饰符"></a>1、Java修饰符</h3><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>
<ul>
<li>访问控制修饰符 : default, public , protected, private</li>
<li>非访问控制修饰符 : final, abstract, static, synchronized</li>
</ul>
<h3 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h3><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p>
<p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（sub class）。</p>
<h3 id="3、接口"><a href="#3、接口" class="headerlink" title="3、接口"></a>3、接口</h3><p>在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p>
<p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>
<h3 id="4、Java-源程序与编译型运行区别"><a href="#4、Java-源程序与编译型运行区别" class="headerlink" title="4、Java 源程序与编译型运行区别"></a>4、Java 源程序与编译型运行区别</h3><p>如下图所示：</p>
<p><img src="/cainiao-java-learning/ZSSDMld.png" alt="img"></p>
<h3 id="5、文档注释"><a href="#5、文档注释" class="headerlink" title="5、文档注释"></a>5、文档注释</h3><p>文档注释以 <strong>&#x2F;*</strong>* 开始，以 ***&#x2F;** 结束，通常出现在类、方法、字段等的声明前面，用于生成代码文档，这种注释可以被工具提取并生成 API 文档，如 JavaDoc。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这是一个文档注释示例</span><br><span class="line"> * 它通常包含有关类、方法或字段的详细信息</span><br><span class="line"> */</span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    // 类的成员和方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档注释的格式通常包含一些特定的标签，如 <strong>@param</strong> 用于描述方法参数，**@return** 用于描述返回值，**@throws** 用于描述可能抛出的异常等等，这些标签有助于生成清晰的API文档，以便其他开发者能够更好地理解和使用你的代码。</p>
<h2 id="二、Java对象和类"><a href="#二、Java对象和类" class="headerlink" title="二、Java对象和类"></a>二、Java对象和类</h2><p><strong>4、封装（Encapsulation）</strong>：</p>
<ul>
<li><p>将对象的状态（字段）私有化，通过公共方法访问。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String name; </span><br><span class="line">public String getName() &#123; return name; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>5、多态（Polymorphism）</strong>：</p>
<ul>
<li><p>对象可以表现为多种形态，主要通过方法重载和方法重写实现。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 方法重载：`public int add(int a, int b) &#123; ... &#125;` 和 `public double add(double a, double b) &#123; ... &#125;`</span><br><span class="line"></span><br><span class="line">- 方法重写：`@Override public void makeSound() &#123; System.out.println(&quot;Meow&quot;); &#125;`</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>6、抽象（Abstraction）</strong>：</p>
<ul>
<li><p>使用抽象类和接口来定义必须实现的方法，不提供具体实现。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 抽象类：`public abstract class Shape &#123; abstract void draw(); &#125;`</span><br><span class="line"></span><br><span class="line">- 接口：`public interface Animal &#123; void eat(); &#125;`</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>9、方法重载（Method Overloading）</strong>：</p>
<ul>
<li><p>同一个类中可以有多个同名的方法，但参数不同。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MathUtils &#123;</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double add(double a, double b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>对象和类的概念。</p>
<ul>
<li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
</ul>
<h3 id="Java-中的类"><a href="#Java-中的类" class="headerlink" title="Java 中的类"></a>Java 中的类</h3><p>类可以看成是创建 Java 对象的模板。</p>
<p><img src="/cainiao-java-learning/20210105-java-object-1.png" alt="img"></p>
<p>一个类可以包含以下类型变量：</p>
<ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会<strong>为该类提供一个默认构造方法</strong>。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<p>下面是一个构造方法示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Puppy&#123;</span><br><span class="line">    public Puppy()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Puppy(String name)&#123;</span><br><span class="line">        // 这个构造器仅有一个参数：name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p>
<ul>
<li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li>
<li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li>
<li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li>
</ul>
<p>下面是一个创建对象的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Puppy&#123;</span><br><span class="line">   public Puppy(String name)&#123;</span><br><span class="line">      //这个构造器仅有一个参数：name</span><br><span class="line">      System.out.println(&quot;小狗的名字是 : &quot; + name ); </span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">      // 下面的语句将创建一个Puppy对象</span><br><span class="line">      Puppy myPuppy = new Puppy( &quot;tommy&quot; );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、DO、BO、DTO、VO、AO、PO、UID等术语解释"><a href="#三、DO、BO、DTO、VO、AO、PO、UID等术语解释" class="headerlink" title="三、DO、BO、DTO、VO、AO、PO、UID等术语解释"></a>三、DO、BO、DTO、VO、AO、PO、UID等术语解释</h2><p>在Java开发中，DO、BO、DTO、VO、AO、PO、UID等术语通常用于表示不同的对象类型或概念。以下是它们的常见含义：</p>
<ol>
<li><strong>DO (Data Object &#x2F; Domain Object)</strong>:<ul>
<li><strong>数据对象</strong>或<strong>领域对象</strong>，通常与数据库表直接对应，用于表示持久化数据。</li>
<li>例如，一个<code>UserDO</code>可能对应数据库中的<code>user</code>表。</li>
</ul>
</li>
<li><strong>BO (Business Object)</strong>:<ul>
<li><strong>业务对象</strong>，封装了业务逻辑和操作，通常由多个DO或其他BO组合而成。</li>
<li>例如，一个<code>OrderBO</code>可能包含订单信息、用户信息和商品信息。</li>
</ul>
</li>
<li><strong>DTO (Data Transfer Object)</strong>:<ul>
<li><strong>数据传输对象</strong>，用于在不同层（如服务层和表现层）之间传输数据。</li>
<li>例如，<code>UserDTO</code>可能包含用户的基本信息，用于前端展示。</li>
</ul>
</li>
<li><strong>VO (Value Object)</strong>:<ul>
<li><strong>值对象</strong>，通常用于表示一个不可变的对象，包含一些属性但没有行为。</li>
<li>例如，<code>AddressVO</code>可能包含地址的详细信息。</li>
</ul>
</li>
<li><strong>AO (Application Object)</strong>:<ul>
<li><strong>应用对象</strong>，用于表示应用程序中的某个实体或概念，通常包含业务逻辑。</li>
<li>例如，<code>ReportAO</code>可能表示一个报表对象，包含生成报表的逻辑。</li>
</ul>
</li>
<li><strong>PO (Persistent Object)</strong>:<ul>
<li><strong>持久化对象</strong>，与DO类似，通常用于表示与数据库表直接对应的对象。</li>
<li>例如，<code>UserPO</code>可能对应数据库中的<code>user</code>表。</li>
</ul>
</li>
<li><strong>UID (Unique Identifier)</strong>:<ul>
<li><strong>唯一标识符</strong>，用于唯一标识某个对象或实体。</li>
<li>例如，<code>userId</code>可能是一个用户的唯一标识符。</li>
</ul>
</li>
</ol>
<p>这些术语的具体使用可能因项目或团队的不同而有所差异，但它们的核心概念通常是相似的。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客next主题下不蒜子busuanzi访问量统计不显示</title>
    <url>/2019/03/27/busuanzi-error-solve/</url>
    <content><![CDATA[<p>首先明确在hexo博客的主题配置时，有两个文件经常会用到。一个是blog根目录下的<code>_config.yml</code>文件，我们称其为<strong>站点配置文件</strong>，另一个则是<code>themes\next</code>下的<code>_config.yml</code>文件，我们称其为<strong>主题配置文件</strong>，在主题配置文件内next本身已自集成了一个统计算法，具体的用法如下:</p>
<span id="more"></span>

<p>打开<strong>主题配置文件</strong>，建议用Sublime Text打开，可以使用<code>ctrl+f</code>快捷键，输入<code>busuanzi</code>,你会看到以下代码:（V5版本)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: false</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; </span><br><span class="line">  site_uv_footer: </span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">  site_pv_footer: </span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">  page_pv_footer: ```</span><br><span class="line">（v7版本）</span><br></pre></td></tr></table></figure>
<p>busuanzi_count:<br>  enable: false<br>  total_visitors: true<br>  total_visitors_icon: user<br>  total_views: true<br>  total_views_icon: eye<br>  post_views: true<br>  post_views_icon: eye&#96;&#96;&#96;<br>两个版本的算法虽然在具体细节上有所不同，但总的来说大同小异，使用方法都是将<code>enable: false</code>语句更改为<code>enable: true</code>，改完之后就可以在网站底部看到浏览量已经显示出来了。</p>
<p>这时v5版本的用户可能会发现浏览量依旧显示不出来，打开控制台查看发现是因为<code>不蒜子</code>的js文件找不到所以出错了，据<code>不蒜子</code>的作者<a href="http://ibruce.info/2015/04/04/busuanzi/">不蒜子官方网站</a>介绍是原先的域名失效了，所以不得已更换了新的域名。所以现在我们要在js文件里重新引用一下，接下来是解决方法：</p>
<p>简单来讲就是将<code>next</code>主题下<code>不蒜子</code>的js引用文件更改一下即可。我们首先进去blog根目录下的<code>themes</code>文件夹，找到我们在用的<code>next</code>主题文件夹，然后在<code>\layout\_third-party\analytics</code>下找到<code>busuanzi-counter.swig</code>文件，右击用sublime text打开，在该文件下找到如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>将这句话更改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>然后再刷新下页面，就大功告成啦~总的来说解决问题的方法不难，不过不清楚门道的话不知道怎么改，反正我折腾了很久就是了</p>
<h3 id="祝大家建站快乐，少遇坑"><a href="#祝大家建站快乐，少遇坑" class="headerlink" title="祝大家建站快乐，少遇坑~"></a>祝大家建站快乐，少遇坑~</h3>]]></content>
      <categories>
        <category>建站填坑</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>分享</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>系统研发脚手架初始化SOP</title>
    <url>/2024/07/11/environment-init-notes/</url>
    <content><![CDATA[<p>拉取前后端脚手架之后的一些开发初始化操作及常见问题记录。</p>
<span id="more"></span>

<h2 id="一、后端"><a href="#一、后端" class="headerlink" title="一、后端"></a>一、后端</h2><ol>
<li><p>脚手架生成中心填写信息，生成脚手架；</p>
</li>
<li><p>在数据库服务器上新建项目所属数据库；</p>
</li>
<li><p>更改application-local中的jdbc连接信息；（数据库服务器地址、用户名、用户密码、数据库名）</p>
</li>
<li><p>使用scripts&#x2F;sql中的MySQL建表语句在navicat中导入初始系统表；</p>
</li>
<li><p>打开File—Settings—Compiler—“Shared build process heap VM options”设置为以下值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Djps.track.ap.dependencies=false</span><br></pre></td></tr></table></figure>
</li>
<li><p>右上角添加“test“的application运行配置：Add New Configuration—Application—设置name—Build and run选择Application（com.XXXXX项目名称）</p>
</li>
<li><p>在项目数据库下根据前期表结构设计文档，新建业务表</p>
</li>
<li><p>使用postman跳过token校验，修改application-local中的shiro-auth后面的路径，即可跳过校验；</p>
</li>
<li><p>拆分业务代码架构需要在代码原始配置中增加扫描路径，autoconfiguration中添加相关代码路径；</p>
</li>
</ol>
<h2 id="二、前端"><a href="#二、前端" class="headerlink" title="二、前端"></a>二、前端</h2><ol>
<li><p>脚手架生成中心填写信息，生成脚手架；</p>
</li>
<li><p>package-lock.json是自动生成的文件，重新下载需要和node_modules文件夹一起删除，重新下载，建议使用yarn install命令安装；</p>
</li>
<li><p>npmrc文件需要把最后一行的注释解除，改为自己项目的路径；</p>
</li>
<li><p>在terminal终端窗口使用以下命令下载项目所需包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="三、问题记录"><a href="#三、问题记录" class="headerlink" title="三、问题记录"></a>三、问题记录</h2><p>1、implement methods：实现基类或接口中的方法；</p>
<p>2、@RestController注解：类中的方法返回的数据可以直接作为HTTP响应的内容，而不需要通过视图解析器进行渲染。</p>
<p>3、@ComponentScan注解：将组件自动加载到容器，加了包扫描@ComponentScan注解后，只要标注了@Controller、@Service、@Repository、@Component注解中的任何一个，其组件都会被自动扫描，加入到容器中。</p>
<p>4、热加载：如果是<strong>方法内部的修改或者静态资源的修改</strong>，在 IDEA 中是可以通过 <strong>Rebuild</strong>（Ctrl + Shift + F9）进行热加载的；</p>
<p>5、遇到无法实例化的问题，到ComponentScan里面增加我们开发的项目路径；</p>
<p>6、PO层设置了mybatis自动注入时间，但是@TableField(fill&#x3D;FieldFill.INSERT)注解无法正常写入时间，需要检查MetaObjectHandler的具体实现，搞清楚自动注入的规则，可能只有固定的字段能被注入；</p>
<p>7、进入列模块编辑模式：SHIFT+ALT+INSERT</p>
<p>8、idea删除未使用的包快捷键： Ctrl + Alt + O</p>
<p>9、java: Can‘t generate mapping method with primitive return type.Mapper无法正常导入类：@Mapper导入的包出错了；</p>
<p>10、ctrl+shift+f全局搜；shift+shift搜索类；ctrl+shift+r全局替换；</p>
<p>11、mysql怎么批量杀死进程：<a href="https://blog.csdn.net/yanhang0610/article/details/52724009">https://blog.csdn.net/yanhang0610/article/details/52724009</a></p>
<p>12、idea环境下使用git提交代码、push代码，需要先checkout到remote的master分支，此基础上修改再提交可以成功，否则直接提交会显示用户为appuser@localhost被remote的库拒绝提交，且任务编号应处于正常状态；</p>
<p>13、Boolean和boolean的区别？</p>
<ul>
<li><code>Boolean</code> 是一个类，属于 <code>java.lang</code> 包，用于表示布尔值的封装类型。它提供了多个静态常量和方法，例如 <code>Boolean.TRUE</code> 和 <code>Boolean.FALSE</code>、valueOf（boolean b）。占用的内存更多，因为它是一个对象，包含了其他的信息，如哈希码等。</li>
<li><code>boolean</code> 是一个原始数据类型，用于直接存储布尔值，只有两个值true和false。是一个8位的值，在物理存储上只占用一个字节。</li>
</ul>
<p>14、按照DDD标准新增一个模块的全生命周期，需要至少需要新增17个类，其中11个class，6个interface；</p>
<p>15、MyBatis-Plus中LambdaQueryWrapper的使用详解：<a href="https://cloud.baidu.com/article/3314759">https://cloud.baidu.com/article/3314759</a></p>
<p><strong>参考链接：</strong></p>
<p>IDEA常用快捷键汇总：<a href="https://blog.csdn.net/weixin_45433031/article/details/106166961">https://blog.csdn.net/weixin_45433031/article/details/106166961</a></p>
<p>热加载、热重启：<a href="https://www.jb51.net/program/304976b3l.htm">https://www.jb51.net/program/304976b3l.htm</a></p>
<p>@TableField(fill&#x3D;FieldFill.INSERT)注解无法生效：<a href="https://blog.csdn.net/weixin_44892327/article/details/135935914">https://blog.csdn.net/weixin_44892327/article/details/135935914</a></p>
<p>Mapper导入的包出错：<a href="https://blog.csdn.net/qq_44980517/article/details/136235957">https://blog.csdn.net/qq_44980517/article/details/136235957</a></p>
<p>。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>研发脚手架初始环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>git分布式管理系统常用指令</title>
    <url>/2019/08/01/git-instructions/</url>
    <content><![CDATA[<p>参考资料：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰git教程</a>)</p>
<h2 id="1-git是什么？"><a href="#1-git是什么？" class="headerlink" title="1.git是什么？"></a>1.git是什么？</h2><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。那什么是版本控制系统？</p>
<blockquote>
<p>如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：<br>想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：</p>
</blockquote>
<span id="more"></span>
<img src="/2019/08/01/git-instructions/git%E4%BE%8B%E5%AD%90.jpg" class="" title="git例子">

<p>于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？这个软件用起来就应该像这个样子，能记录每次文件的改动：这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。</p>
<h2 id="2-集中式VS分布式"><a href="#2-集中式VS分布式" class="headerlink" title="2.集中式VS分布式"></a>2.集中式VS分布式</h2><p><strong>集中式：</strong><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<img src="/2019/08/01/git-instructions/%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.jpg" class="" title="集中式管理系统">
<p>缺点：</p>
<ul>
<li>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</li>
<li>而且集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</li>
</ul>
<p><strong>分布式：</strong><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<img src="/2019/08/01/git-instructions/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.jpg" class="" title="分布式管理系统">
<p>优点：<br>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。</p>
<h2 id="3-创建版本库"><a href="#3-创建版本库" class="headerlink" title="3.创建版本库"></a>3.创建版本库</h2><h3 id="3-1创建版本库"><a href="#3-1创建版本库" class="headerlink" title="3.1创建版本库"></a>3.1创建版本库</h3><ul>
<li>1.选择一个合适的地方，创建一个空目录。pwd命令用于显示当前目录。在下面例子中，这个仓库位于<code>/Users/vikee/learngit</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir learngit</span><br><span class="line">cd learngit</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure></li>
<li>2.通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：<code>git init</code>。瞬间Git就把仓库建好了，而且告诉你这里是一个空的仓库<code>empty Git repository</code>，细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</li>
</ul>
<h3 id="3-2把文件添加到版本库"><a href="#3-2把文件添加到版本库" class="headerlink" title="3.2把文件添加到版本库"></a>3.2把文件添加到版本库</h3><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。<br>假设我们在<code>learngit</code>目录下（子目录也行，因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件）编写了一个readme.txt文件，现在我们要将其上传到版本库中。</p>
<ul>
<li>1.用命令<code>git add</code>告诉Git，把文件添加到仓库，若没有任何显示的话表明添加成功： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure></li>
<li>2.用命令<code>git commit</code>告诉Git，把文件提交到仓库,其中<code>git commit</code>命令的<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。<code>git commit</code>命令执行成功后会告诉你，<code>1 file changed：</code>1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions：</code>插入了两行内容（readme.txt有两行内容）。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line">1 file changed, 2 insertions(+)</span><br><span class="line">create mode 100644 readme.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add file1.txt</span><br><span class="line">git add file2.txt file3.txt</span><br><span class="line">git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure>
<h2 id="4-版本管理"><a href="#4-版本管理" class="headerlink" title="4.版本管理"></a>4.版本管理</h2><h3 id="4-1版本回退"><a href="#4-1版本回退" class="headerlink" title="4.1版本回退"></a>4.1版本回退</h3><p>在你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<ul>
<li><p>1.<code>git log</code>:可以查看提交历史，命令显示从最近到最远的提交日志，以便确定要回退到哪个版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line">    add distributed</span><br></pre></td></tr></table></figure>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数，一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号）,这是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.<code>git reset</code>:回退到之前的版本。在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;想要再返回当前版本时，使用<code>git log</code>指令找到最新版本的提交ID，假设最新版本的提交ID是<code>1094adb...</code>可以使用如下命令返回,版本号没必要写全，前几位就可以了，Git会自动去找，至少前5位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把<code>HEAD</code>从指向<code>append GPL</code>(最新版本)改为指向<code>add distributed</code>（上一版本）。然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
<img src="/2019/08/01/git-instructions/%E5%9C%B0%E5%9D%80%E6%9B%B4%E6%94%B9%E5%89%8D.png" class="" title="地址更改前">
<img src="/2019/08/01/git-instructions/%E5%9C%B0%E5%9D%80%E6%9B%B4%E6%94%B9%E5%90%8E.png" class="" title="地址更改后">
</li>
<li><p>3.<code>git reflog</code>：查看命令历史，以便确定要回到未来的哪个版本。当你回退到上一版本退出命令行界面之后，找不到实际上文件最新版本的<code>commit id</code>时,就可以用<code>git reflog</code>找到之后的id。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2工作区和暂存区"><a href="#4-2工作区和暂存区" class="headerlink" title="4.2工作区和暂存区"></a>4.2工作区和暂存区</h3><p><strong>工作区（Working Directory）：</strong><br>在电脑里能看到的目录，比如下面的learngit文件夹就是一个工作区。</p>
<img src="/2019/08/01/git-instructions/%E5%B7%A5%E4%BD%9C%E5%8C%BA.png" class="" title="工作区">

<p><strong>版本库（Repository）：</strong><br>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。<br>Git的版本库里存了很多东西，其中最重要的就是称为<code>stage</code>（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向master的一个指针叫<code>HEAD</code>。</p>
<img src="/2019/08/01/git-instructions/%E7%89%88%E6%9C%AC%E5%BA%93.jpg" class="" title="版本库">

<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<ul>
<li>1.用<code>git add</code>文件添加进去，实际上就是把文件修改添加到<strong>暂存区</strong>；</li>
<li>2.用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容<strong>提交到当前分支</strong>。在创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用<code>git status</code>查看一下工作区各个文件的状态。<code>modified</code>表明文件被修改了。<code>Untracked</code>则表明文件是新增的，还未被添加到暂存区中。
</li>
</ul>
<h3 id="4-3管理修改"><a href="#4-3管理修改" class="headerlink" title="4.3管理修改"></a>4.3管理修改</h3><p>为什么Git比其他版本控制系统设计得优秀？因为Git跟踪并管理的是修改，而非文件。</p>
<ul>
<li>1.假设一个文件read.txt增加了一行内容。然后使用<code>git add</code>将文件添加到缓存区。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes.//增加的内容</span><br></pre></td></tr></table></figure></li>
<li>2.在上一步的基础上，我们又修改了文件的内容。然后使用<code>git commit</code>将文件提交到当前分支。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt </span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure>
提交后，再使用<code>git status</code>状态,发现第二次的修改没有更新，只有第一次的修改更新到了当前分支中。我们可以仔细分析一下以上文件修改和提交的过程：第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code>。不难发现第二次修改之后并没有使用<code>git add</code>提交文件到缓存区，所以第一次的修改被提交了，第二次的文件并没有被提交。</li>
<li>3.提交后，使用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别。</li>
</ul>
<h3 id="4-4撤销修改"><a href="#4-4撤销修改" class="headerlink" title="4.4撤销修改"></a>4.4撤销修改</h3><p>修改文件内容后想恢复到上一个版本时。使用<code>git checkout -- file</code>可以丢弃工作区的修改，该指令的意思是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况,总之就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态：</p>
<ul>
<li>1.<code>readme.txt</code>自修改后还<strong>没有被放到暂存区</strong>，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>2.<code>readme.txt</code>已经<strong>添加到暂存区</strong>，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
</ul>
<p><strong>注意：</strong><code>git checkout -- file</code>命令中的–很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，</p>
<p>当文件已经被添加到暂存区，还没有被提交。想要撤回修改可以使用以下两步：</p>
<ul>
<li>1.用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区,<code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	readme.txt</span><br></pre></td></tr></table></figure></li>
<li>2.使用第一步的指令，再用<code>git status</code>查看当前状态，可以发现暂存区是干净的，工作区有修改。那丢弃工作区的修改，可以使用上面方法中的<code>git checkout -- file</code>指令。</li>
</ul>
<h3 id="4-5删除文件"><a href="#4-5删除文件" class="headerlink" title="4.5删除文件"></a>4.5删除文件</h3><ul>
<li>1.一般情况下，通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删除：<code>rm test.txt</code>;</li>
<li>2.这时Git知道你删除了文件，因此，工作区和版本库不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了;</li>
<li>3.现在你有两个选择,一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;另一种情况则是不小心删错了，因为版本库里还有最新的版本，所以可以很轻松地把误删的文件恢复到最新版本：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<strong>注意：</strong><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。<strong>但如果是从来没有被添加到版本库就被删除的文件，是无法恢复的！</strong></li>
</ul>
<h2 id="5-分支管理"><a href="#5-分支管理" class="headerlink" title="5.分支管理"></a>5.分支管理</h2><h3 id="5-1创建与合并分支"><a href="#5-1创建与合并分支" class="headerlink" title="5.1创建与合并分支"></a>5.1创建与合并分支</h3><p>在版本回退里，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的是<strong>当前分支</strong>。</p>
<ul>
<li>1.开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD指</code>向<code>master</code>，就能确定当前分支，以及当前分支的提交点,每次提交，<code>master</code>支都会向前移动一步，这样随着你不断提交，<code>master</code>分支的线也越来越长。<img src="/2019/08/01/git-instructions/%E5%88%86%E6%94%AF%E6%AD%A5%E9%AA%A41.png" class="" title="分支步骤1"></li>
<li>2.当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上,Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！<img src="/2019/08/01/git-instructions/%E5%88%86%E6%94%AF%E6%AD%A5%E9%AA%A42.png" class="" title="分支步骤2"></li>
<li>3.从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变。<img src="/2019/08/01/git-instructions/%E5%88%86%E6%94%AF%E6%AD%A5%E9%AA%A43.png" class="" title="分支步骤3"></li>
<li>4.假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并。<img src="/2019/08/01/git-instructions/%E5%88%86%E6%94%AF%E6%AD%A5%E9%AA%A44.png" class="" title="分支步骤4"></li>
<li>5.合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，之后就剩下了一条<code>master</code>分支。</li>
</ul>
<p><strong>具体的指令：</strong><br>查看分支：<code>git branch</code>。<code>git branch</code>命令会列出所有分支，当前分支前面会标一个*号</p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h3 id="5-2解决冲突"><a href="#5-2解决冲突" class="headerlink" title="5.2解决冲突"></a>5.2解决冲突</h3><p>当一个文件的不同分支，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p>
<img src="/2019/08/01/git-instructions/%E5%88%86%E6%94%AF%E5%90%84%E6%9C%89%E4%BF%AE%E6%94%B9.png" class="" title="分支各有修改">
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，Git告诉我们，当前的文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件。解决冲突的方法如下：</p>
<ul>
<li>1.直接查看存在冲突文件的内容,Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></li>
<li>2.我们修改文件之后如下后保存。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure></li>
<li>3.再使用<code>git commit</code>指令将修改提交。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;conflict fixed&quot;</span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure>
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;现在<code>master</code>分支和<code>feature1</code>分支变成了下图所示：<img src="/2019/08/01/git-instructions/%E5%86%B2%E7%AA%81%E4%BF%AE%E6%94%B9%E4%B9%8B%E5%90%8E.png" class="" title="冲突修改之后"></li>
<li>4.最后，删除feature1分支：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 14096d0).</span><br></pre></td></tr></table></figure>
<strong>注意:</strong><br>用<code>git log --graph</code>命令可以看到分支合并图。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git踩坑记录</title>
    <url>/2024/10/09/git-learning-record/</url>
    <content><![CDATA[<h2 id="1、-lt-lt-lt-lt-lt-lt-lt-HEAD-gt-gt-gt-gt-gt-gt-gt-dev什么意思？"><a href="#1、-lt-lt-lt-lt-lt-lt-lt-HEAD-gt-gt-gt-gt-gt-gt-gt-dev什么意思？" class="headerlink" title="1、&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev什么意思？"></a>1、&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev什么意思？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">// 你的 &#x27;HEAD&#x27; 分支的代码</span><br><span class="line">=======</span><br><span class="line">// 你尝试合并的分支的代码</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></pre></td></tr></table></figure>

<p>这表示你遇到了一个合并冲突。Git 在尝试合并两个分支时，如果发现有相同的文件在两个分支中都有修改，但是修改的内容不一致，Git 就无法自动合并这些更改，这时候就需要你手动解决冲突。</p>
<span id="more"></span>

<p>这段标记的具体含义是：</p>
<ul>
<li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>：表示接下来的代码是你当前 <code>HEAD</code> 分支（即你正在合并到的分支）中的版本。</li>
<li><code>=======</code>：这是分隔符，用来区分不同分支的代码。</li>
<li><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</code>：表示上面的代码是你尝试合并的分支（在这个例子中是 <code>dev</code> 分支）中的版本。</li>
</ul>
<p>你需要决定要保留哪个版本的代码，或者结合两个版本的代码。解决冲突后，你需要使用以下命令来标记冲突已解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;解决合并冲突&quot;</span><br></pre></td></tr></table></figure>

<p>完成这些步骤后，合并冲突就会被视为已解决，你可以继续合并操作。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer——1.二维数组中的查找</title>
    <url>/2019/07/27/jianzhioffer01/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h3><p>假设选定一个要查找的数字，如果在数组中任意选取一个数字来和该数字作比较，可能会导致下一次要查找的区域发生重叠。为了简化查找过程，我们可以选取每个查找区域右上角数据（左下角数据也可，原理相同）和要查找的数字进行比较。此时只会发生三种情况：</p>
<span id="more"></span>
<ul>
<li>右上角的数字等于要查找的数字。查找过程结束。</li>
<li>右上角的数字大于要查找的数字。根据该二维数组的特征，排除右上角数字所在的列。</li>
<li>右上角的数字小于要查找的数字。同理，排除右上角数字所在的行。</li>
</ul>
<p>重复以上1~3步，如果要查找的数字不在所查找区域的右上角，那么就每一次都排除一行或者一列，逐渐缩小查找范围，直到找到要查找的数字，或者查找结果为空。</p>
<h3 id="3-举例说明"><a href="#3-举例说明" class="headerlink" title="3.举例说明"></a>3.举例说明</h3><img src="/2019/07/27/jianzhioffer01/%E6%95%B0%E7%BB%84%E4%B8%BE%E4%BE%8B.jpg" class="" title="数组举例">
<img src="/2019/07/27/jianzhioffer01/%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.jpg" class="" title="查找过程">

<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p><strong>c++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        int rows = array.size();//数组的行序号</span><br><span class="line">        int cols = array[0].size();//数组的列序号</span><br><span class="line">        if(!array.empty() &amp;&amp; rows &gt; 0 &amp;&amp; cols &gt; 0)&#123;//若数组内容非空、行列序号均大于零</span><br><span class="line">            int row = 0;</span><br><span class="line">            int col = cols - 1;//右上角数据的行、列序号</span><br><span class="line">            while(row &lt; rows &amp;&amp; col &gt;= 0)&#123;//当右上角数据存在时</span><br><span class="line">                if(array[row][col] == target)&#123;</span><br><span class="line">                    return true;//若两数相同，查找结束</span><br><span class="line">                &#125;</span><br><span class="line">                else if(array[row][col] &gt; target)&#123;//若右上角数字大于被查找数，行不变，列减少</span><br><span class="line">                    --col;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    ++row;//若右上角数字小于被查找数，行增加，列不变</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;//否则，数组中不存在被查找数，查找失败</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python2.7：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    # array 二维列表</span><br><span class="line">    def Find(self, target, array):</span><br><span class="line">        # write code here</span><br><span class="line">        rows = len(array)</span><br><span class="line">        cols = len(array[0])</span><br><span class="line">        if rows &gt; 0 and cols &gt; 0:</span><br><span class="line">            row = 0</span><br><span class="line">            col = cols - 1</span><br><span class="line">            while row &lt; rows and col &gt;= 0:</span><br><span class="line">                if target == array[row][col]:</span><br><span class="line">                    return True</span><br><span class="line">                elif target &lt; array[row][col]:</span><br><span class="line">                    col -= 1</span><br><span class="line">                else:</span><br><span class="line">                    row += 1</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer——2.替换空格</title>
    <url>/2019/07/27/jianzhioffer02/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;拿到字符串之后，很容易想到有两种方式完成替换。第一种：从头到尾遍历，在原字符串的基础上进行替换。这种方式的缺点在于靠后的字符串会多次移动，因此对于含有O（n）个<strong>空格字符</strong>的字符串而言时间复杂度是O（n2）。第二种：创建一个新的字符串，并在其上进行替换。这种方式需要我们自己分配足够的内存空间。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文采用了一种使用<strong>从后向前遍历</strong>实现空格替换的方法，这种方法中所有的字符串只需要移动一次，因此这个算法的时间复杂度为O（n）。总体的算法步骤如下：</p>
<span id="more"></span>
<ul>
<li>先遍历一次字符串，得到字符串中的空格个数，以及插入新字符之前的原字符串长度；</li>
<li>根据第一步的结果，计算出替换完成后新字符串的长度。新字符串长度 &#x3D; 原字符串长度 + 空格个数*2；</li>
<li>给定两个指针a和b，a指向原字符串尾，b指向替换之后的字符串尾。向前移动指针a，逐个把它指向的字符复制到b指向的位置，直到碰到空格，a向前一格，b之前插入字符串”%20”，同时b向前移动3格。</li>
<li>重复第三步，直到a和b指向同一个位置。</li>
</ul>
<h3 id="3-举例说明"><a href="#3-举例说明" class="headerlink" title="3.举例说明"></a>3.举例说明</h3><p>以”We are happy”为例，”We are happy”这个字符串的长度为14（包括结尾符号”\n”），里面有两个空格，因此替换之后字符串的长度是18。我们从字符串的尾部开始复制和替换。首先准备两个指针P1和P2，P1指向原始字符串的末尾，P2指向替换之后的字符串末尾。接下来向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格。碰到第一个空格后，P1向前移动1格，P2位置开始向前插入字符串”%20”，同时P2向前移动3格。</p>
<img src="/2019/07/27/jianzhioffer02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BE%8B%E5%AD%90.jpg" class="" title="字符串例子">

<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p><strong>c++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	void replaceSpace(char *string,int length)&#123;</span><br><span class="line">    if(string == NULL || length &lt;= 0)</span><br><span class="line">    	return;</span><br><span class="line">    //循环遍历数组，得到字符串的总长，以及空格的个数</span><br><span class="line">    int originLength = 0;</span><br><span class="line">    int numSpace = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while(string[i] != &#x27;\0&#x27;)</span><br><span class="line">    	&#123;</span><br><span class="line">        ++originLength;</span><br><span class="line"></span><br><span class="line">        	if(string[i] == &#x27; &#x27;)</span><br><span class="line">            	++numSpace;</span><br><span class="line"></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    //得到新数组所需的字符串长度</span><br><span class="line">    int newLength = originLength + numSpace*2;//新字符串长度 = 原字符串长度 + 空格个数*2；</span><br><span class="line">    if(newLength &gt;length)</span><br><span class="line">    	return;</span><br><span class="line"></span><br><span class="line">	////检索到空格，就将空格替换为‘%’‘2’‘0’</span><br><span class="line">    int p1 = originLength;</span><br><span class="line">    int p2 = newLength;</span><br><span class="line">    while(p1 &gt;= 0 &amp;&amp; p2 &gt; p1 )&#123;</span><br><span class="line">    	if(string[p1] == &#x27; &#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">        	string[p2--] = &#x27;0&#x27;;</span><br><span class="line">            string[p2--] = &#x27;2&#x27;;</span><br><span class="line">            string[p2--] = &#x27;%&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            string[p2--] = string[p1];</span><br><span class="line">        &#125;</span><br><span class="line">        --p1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python2.7:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    # string指代 源字符串</span><br><span class="line">    def replaceSpace(self, string):</span><br><span class="line">        # write code here</span><br><span class="line">        return string.replace(&#x27; &#x27;, &#x27;%20&#x27;)</span><br></pre></td></tr></table></figure>
































]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer——3.从尾到头打印链表</title>
    <url>/2019/08/04/jianzhioffer03/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
</blockquote>
<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;拿到链表之后想要反向输出，最容易想到的方法可能是将指针的指向变为反向，但这样会改变原本的链表结构。所以，通常情况下我们不希望改变原本的链表结构。换个角度思考，反向输出链表，那就是经典的“先进后出”数据结构，即借助栈（stack）这种数据结构完成链表的反转。总体的算法步骤如下：</p>
<span id="more"></span>
<ul>
<li>遍历链表的节点，每经过一个节点，就将该节点放到一个栈当中；</li>
<li>遍历完整个链表过后，再从栈顶开始逐个输出节点的值赋值给新的链表；</li>
</ul>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p><strong>c++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        stack&lt;int&gt; nodes;//栈</span><br><span class="line">        vector&lt;int&gt; result;//新链表</span><br><span class="line">        ListNode* node=head;//原链表</span><br><span class="line">        while(node != NULL)&#123;//遍历原链表，将遍历结果给栈结构nodes</span><br><span class="line">            nodes.push(node-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!nodes.empty())&#123;//当栈非空时，从栈顶依次将节点输出给新链表result</span><br><span class="line">            result.push_back(nodes.top());</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python2.7:</strong><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于python来讲，可以直接使用列表的插入方法，每次插入数据，只插入在首位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"> </span><br><span class="line">class Solution:</span><br><span class="line">    # 返回从尾部到头部的列表值序列，例如[1,2,3]</span><br><span class="line">    def printListFromTailToHead(self, listNode):</span><br><span class="line">        # write code here</span><br><span class="line">        result = []</span><br><span class="line">        while listNode:</span><br><span class="line">            result.insert(0, listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer——4.重建二叉树</title>
    <url>/2019/08/04/jianzhioffer04/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>树是一种经典的数据结构，通常有以下三种遍历方式：</p>
<ul>
<li>1.前序遍历：a.先访问根节点，b.再访问左子节点，c.最后访问右子节点。</li>
<li>2.中序遍历：a.先访问左子节点，b.再访问根节点，c.最后访问右子节点。</li>
<li>3.后序遍历：a.先访问左子节点，b.再访问右子节点，c.最后访问根节点。<br>一般二叉树的重建最少需要两种遍历方式，前序遍历和中序遍历，或者前序遍历和后序遍历。本题目中给出的条件是前序遍历和中序遍历结果，总体的算法步骤如下：<span id="more"></span></li>
<li>前序遍历中，第一个数字总是树的根节点的值；</li>
<li>根据第1步的结果，可以在中序遍历序列中确定，左子树的节点值位于根节点值的左边，右子树节点的值位于根节点值的右边；</li>
<li>剩余数字根据第1、2步递归实现。<img src="/2019/08/04/jianzhioffer04/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BE%8B%E5%AD%90.jpg" class="" title="二叉树例子"></li>
</ul>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p><strong>c++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Definition for binary tree</span><br><span class="line">    * struct TreeNode &#123;</span><br><span class="line">    *     int val;</span><br><span class="line">    *     TreeNode *left;</span><br><span class="line">    *     TreeNode *right;</span><br><span class="line">    *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">    * &#125;;</span><br><span class="line">    */</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">           if (pre.size() == 0)&#123;//若子树为空，则返回NULL</span><br><span class="line">               return NULL;</span><br><span class="line">           &#125;</span><br><span class="line">           //分别是前序左子树，前序又子树，中序左子树，中序右子树</span><br><span class="line">           vector&lt;int&gt; left_pre,right_pre,left_vin,right_vin;</span><br><span class="line">           //前序遍历的第一个数字必定为树的根节点</span><br><span class="line">           TreeNode* head = new TreeNode(pre[0]);</span><br><span class="line">           int root = 0;</span><br><span class="line">           for(int i = 0;i &lt; pre.size();i++)//找到根节点在中序遍历中的位置，在该位置前的为左子树，在该位置之后的为右子树</span><br><span class="line">           &#123;</span><br><span class="line">               if(pre[0] == vin[i])&#123;</span><br><span class="line">                   root = i;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           for(int i = 0;i &lt; root;i++)&#123;//中序遍历中的根节点，对二叉树中的节点进行归并</span><br><span class="line">               left_vin.push_back(vin[i]);</span><br><span class="line">               left_pre.push_back(pre[i+1]);//前序遍历第一个数为根节点</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           for(int i = root+1;i &lt; pre.size();i++)&#123;</span><br><span class="line">               right_vin.push_back(vin[i]);</span><br><span class="line">               right_pre.push_back(pre[i]);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           //递归，对左、右子树进行下一步区分，直到找到树的叶节点</span><br><span class="line">           head-&gt;left = reConstructBinaryTree(left_pre,left_vin);</span><br><span class="line">           head-&gt;right = reConstructBinaryTree(right_pre,right_vin);</span><br><span class="line">           return head;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python2.7:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回构造的TreeNode根节点</span><br><span class="line">    def reConstructBinaryTree(self, pre, tin):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(pre) == 0:</span><br><span class="line">            return None</span><br><span class="line">        elif len(pre) == 1:</span><br><span class="line">            return TreeNode(pre[0])</span><br><span class="line">        else:</span><br><span class="line">            root = TreeNode(pre[0])</span><br><span class="line">            pos = tin.index(pre[0])</span><br><span class="line">            root.left = self.reConstructBinaryTree(pre[1:pos+1], tin[:pos])</span><br><span class="line">            root.right = self.reConstructBinaryTree(pre[pos+1:], tin[pos+1:])</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer——6.旋转数组的最小数字</title>
    <url>/2019/08/04/jianzhioffer06/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 (NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。)</p>
</blockquote>
<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们可以注意到旋转之后的数组其实可以划分为两个排序的子数组，并且该数组的特点是前面的子数组中的元素总是大于或者等于后面子数组的元素。其中最小的元素正好是这两个数组的分界线。本题给出的数组在一定范围内是排序的，因此我们可以用二分查找法来实现O（logn）的查找。具体的算法步骤如下：</p>
<span id="more"></span>
<ul>
<li>以数组{3,4,5,1,2}为例，我们可以找到数组的中间元素，定义两个指针P1和P2，左指针P1指向数组的第一个元素，右指针P2指向最后一个元素。如果中间元素位于前面的递增子数组，那么它应该大于或者等于P1所指向的元素。此时最小元素应该位于该中间元素之后，然后把P1指向该中间元素，移动之后P1仍然处于前面的递增子数组中。</li>
<li>同样，若中间元素位于后面的递增子数组，那么其应该小于P2所指向的元素。此时最小元素应该在该中间元素之前，然后我们把P2指向该中间元素。移动之后P2仍然位于后面的递增子数组中。</li>
<li>P1总是指向前面递增子数组的元素，P2总是指向后面递增子数组的元素，最终P1和P2会指向两个相邻的元素，这就是循环结束的条件。<img src="/2019/08/04/jianzhioffer06/%E6%95%B0%E7%BB%84%E8%BE%93%E5%87%BA%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.jpg" class="" title="数组输出最小数字"></li>
</ul>
<h3 id="3-特殊案例"><a href="#3-特殊案例" class="headerlink" title="3.特殊案例"></a>3.特殊案例</h3><ul>
<li>如果把排序数组的0个元素搬到最后面，这仍然是旋转数组，我们的代码需要支持这种情况。如果发现数组中的第一个数字小于最后一个数字，表明该数组是排序的，就可以直接返回第一个数字了。</li>
<li>下面这种情况，即第一个指针指向的数字、第二个指针指向的数字和中间的数字三者相等，我们无法判断中间的数字1属于前面的递增子数组还是后面的递增子数组。这样的话，我们只能进行顺序查找。<img src="/2019/08/04/jianzhioffer06/%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.jpg" class="" title="数组顺序查找"></li>
</ul>
<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p><strong>C++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        int size = rotateArray.size();                            //数组长度</span><br><span class="line">        if(size == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 0;                                            //左指针P1</span><br><span class="line">        int right = size - 1;                                    //右指针P2</span><br><span class="line">        int mid = 0;                                            //中间指针</span><br><span class="line">        while(rotateArray[left] &gt;= rotateArray[right])&#123;            //确保旋转</span><br><span class="line">            if(right - left == 1)&#123;                                //左右指针相邻</span><br><span class="line">                mid = right;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = left + (right - left) / 2;                    //计算中间指针位置</span><br><span class="line">            //特殊情况：如果无法确定中间元素是属于前面还是后面的递增子数组，只能顺序查找</span><br><span class="line">            if(rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[mid] == rotateArray[left])&#123;</span><br><span class="line">                return MinInOrder(rotateArray, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">            //中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面</span><br><span class="line">            if(rotateArray[mid] &gt;= rotateArray[left])&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            //中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面</span><br><span class="line">            else&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //顺序寻找最小值</span><br><span class="line">    int MinInOrder(vector&lt;int&gt; &amp;num, int left, int right)&#123;</span><br><span class="line">        int result = num[left];</span><br><span class="line">        for(int i = left + 1; i &lt; right; i++)&#123;</span><br><span class="line">            if(num[i] &lt; result)&#123;</span><br><span class="line">                result = num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python2.7：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">       def minNumberInRotateArray(self, rotateArray):</span><br><span class="line">           # write code here</span><br><span class="line">           if len(rotateArray) == 0:</span><br><span class="line">               return 0</span><br><span class="line">           left = 0</span><br><span class="line">           right = len(rotateArray) - 1</span><br><span class="line">           mid = 0</span><br><span class="line">           while rotateArray[left] &gt;= rotateArray[right]:</span><br><span class="line">               if right - left == 1:</span><br><span class="line">                   mid = right</span><br><span class="line">                   break</span><br><span class="line">               mid = left + (right - left) // 2</span><br><span class="line">               if rotateArray[left] == rotateArray[mid] and rotateArray[mid] == rotateArray[right]:</span><br><span class="line">                   return self.minInorder(rotateArray, left, right)</span><br><span class="line">               if rotateArray[mid] &gt;= rotateArray[left]:</span><br><span class="line">                   left = mid</span><br><span class="line">               else:</span><br><span class="line">                   right = mid</span><br><span class="line">           return rotateArray[mid]</span><br><span class="line">       </span><br><span class="line">       def minInorder(self, array, left, right):</span><br><span class="line">           result = array[left]</span><br><span class="line">           for i in range(left+1, right+1):</span><br><span class="line">               if array[i] &lt; result:</span><br><span class="line">                   result = array[i]</span><br><span class="line">           return result</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer——5.用两个栈实现队列</title>
    <url>/2019/08/04/jianzhioffer05/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
</blockquote>
<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>栈的特点是“先进后出”，即最先被压入（push）的元素会被最后一个弹出（pop）。<br>队列的特点是“先进先出”，即最先进入队列的元素会第一个出来。<br>两个数据结构的特点正好完全相反，那可以想到“负负得正”，创建两个栈，将第一个栈stack1中的元素放到第二个栈stack2中，使用两个“先进后出”栈实现一个先进先出的队列。总体的思路如下：</p>
<span id="more"></span>
<ul>
<li>当stack2中不为空，在stack2的栈顶元素是最先进入队列的元素，此时可以弹出。</li>
<li>当stack2中为空时，再把stack1中的元素逐个弹出并压入stack2。</li>
<li>此时先进入队列的元素被压入stack1的栈底，经过弹出和压入操作之后就处于stack2的栈顶，可以直接弹出。若再有新的队列元素，直接将其压入stack1即可。</li>
</ul>
<h3 id="3-举例说明"><a href="#3-举例说明" class="headerlink" title="3.举例说明"></a>3.举例说明</h3><p>通过一个具体的例子分析往该队列插入和删除元素的过程。首先插入一个元素a，先把它插入stack1，此时stack1中的元素有{a}，stack2为空。再压入两个元素b和c，还是插入到stack1中，此时stack1的元素有{a,b,c}，其中c位于栈顶，而stack2仍然是空的。</p>
<p>这时试着从队列中删除一个元素:</p>
<ul>
<li>按照先入先出的规则，由于a比b、c先插入队列中，最先删除的元素应该是a。元素a存储在stack1中，但并不在栈顶，因此不能直接进行删除操作。</li>
<li>如果把stack1中的元素逐个弹出压入stack2，元素在stack2中的顺序正好和原来在stack1中的顺序相反。</li>
<li>因此经过3次弹出stack1和要入stack2操作之后，stack1为空，而stack2中的元素是{c,b,a}，这个时候就可以弹出stack2的栈顶a了。此时的stack1为空，而stack2的元素为{b,a}，其中b在栈顶。<img src="/2019/08/04/jianzhioffer05/%E4%BE%8B%E5%AD%90.jpg" class="" title="例子"></li>
</ul>
<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p><strong>c++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">   &#123;</span><br><span class="line">   public:</span><br><span class="line">       void push(int node) &#123;</span><br><span class="line">           stack1.push(node);//新元素加入stack1中</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       int pop() &#123;</span><br><span class="line">           if(stack2.empty())&#123;//当stack2中的元素为空时，将stack1中的栈顶元素逐个弹出并压入stack2</span><br><span class="line">               while(stack1.size()&gt;0)&#123;</span><br><span class="line">                   int data = stack1.top();</span><br><span class="line">                   stack1.pop();</span><br><span class="line">                   stack2.push(data);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           int pop_elem = stack2.top();//弹出元素为stack2的栈顶元素</span><br><span class="line">           stack2.pop();</span><br><span class="line">           return pop_elem;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">   private:</span><br><span class="line">       stack&lt;int&gt; stack1;</span><br><span class="line">       stack&lt;int&gt; stack2;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python2.7:</strong><br>对于python来讲，栈就是用list实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">       def __init__(self):</span><br><span class="line">           self.stack1 = []</span><br><span class="line">           self.stack2 = []</span><br><span class="line">       def push(self, node):</span><br><span class="line">           # write code here</span><br><span class="line">           self.stack1.append(node)</span><br><span class="line">       def pop(self):</span><br><span class="line">           # return xx</span><br><span class="line">           if len(self.stack2) == 0:</span><br><span class="line">               while self.stack1:</span><br><span class="line">                   self.stack2.append(self.stack1.pop())</span><br><span class="line">           return self.stack2.pop()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer——7.裴波那契数列</title>
    <url>/2019/08/10/jianzhioffer07/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;&#x3D;39）<br>  斐波那契数列公式为：</p>
</blockquote>
<img src="/2019/08/10/jianzhioffer07/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%85%AC%E5%BC%8F.jpg" class="" title="斐波那契数列公式">

<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>我们可以以求解f（10）为例来分析递归的求解过程。想要求得f（10），我们要先知道f（9）和f（8）。同样的，要求得f（9），需要先知道f（8）和f（7）。。。我们可以使用树形结构来表示这种依赖关系，如下图所示。</p>
<span id="more"></span>
<img src="/2019/08/10/jianzhioffer07/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.jpg" class="" title="斐波那契树形结构">

<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不难发现在这棵树中有许多的节点都是重复的，而且重复的节点数会随着n的增大而急剧增加，这意味着计算量会随着n的增大而急剧增大。事实上用递归方法计算的时间复杂度是以n的指数方式递增的。改进上述方法并不难，只要想办法避免重复计算就可以了，比如可以将已经得到的数列中间项保存起来，如果下次需要计算的话先查找一下，已经计算过的就不用重复再计算了。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;更简单的办法是从下往上计算，即使用简单的循环方法来实现。</p>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p><strong>C++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       int Fibonacci(int n) &#123;</span><br><span class="line">           if(n &lt;= 0)&#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if(n ==1 )&#123;</span><br><span class="line">               return 1;</span><br><span class="line">           &#125;</span><br><span class="line">           int first = 0,second = 1,third = 0;</span><br><span class="line">           for(int i = 2;i &lt;= n;i++)&#123;</span><br><span class="line">               third = first + second;</span><br><span class="line">               first = second;</span><br><span class="line">               second = third;</span><br><span class="line">           &#125;</span><br><span class="line">           return third;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python2.7：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">       def Fibonacci(self, n):</span><br><span class="line">           # write code here</span><br><span class="line">           if n &lt;= 1:</span><br><span class="line">               return n</span><br><span class="line">           first, second, third = 0, 1, 0</span><br><span class="line">           for i in range(2, n+1):</span><br><span class="line">               third = first + second</span><br><span class="line">               first = second</span><br><span class="line">               second = third</span><br><span class="line">           return third</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>如何杀死目标端口号进程</title>
    <url>/2024/02/04/kill-pc-port-task/</url>
    <content><![CDATA[<h3 id="一、查找占用端口号的进程"><a href="#一、查找占用端口号的进程" class="headerlink" title="一、查找占用端口号的进程"></a>一、查找占用端口号的进程</h3><p>在对端口号进行操作之前，需要先找到占用该端口号的进程，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr :端口号</span><br></pre></td></tr></table></figure>

<p>其中，“端口号”是需要杀死进程的端口号。</p>
<p>执行该命令后，将会显示所有占用该端口号的进程，其中最后一列是该进程的PID（进程ID）。</p>
<span id="more"></span>

<h2 id="二、通过PID杀死进程"><a href="#二、通过PID杀死进程" class="headerlink" title="二、通过PID杀死进程"></a>二、通过PID杀死进程</h2><p>获取到PID后，可以使用以下命令杀死对应的进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskkill /pid 进程PID /f</span><br></pre></td></tr></table></figure>

<p>其中，“进程PID”是需要杀死的进程的PID。参数&#x2F;f表示强制终止该进程。</p>
<p>执行该命令后，该进程将会被强制终止。</p>
<h2 id="三、通过端口号杀死进程"><a href="#三、通过端口号杀死进程" class="headerlink" title="三、通过端口号杀死进程"></a>三、通过端口号杀死进程</h2><p>如果不想先通过netstat命令获取到进程的PID，也可以直接使用以下命令杀死对应端口号的进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskkill /f /pid $(netstat -ano | findstr :端口号 | awk &#x27;&#123;print $5&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p>其中，“端口号”是需要杀死进程的端口号。该命令将会自动查找到对应的PID并杀死进程。</p>
<h2 id="四、通过进程名杀死进程"><a href="#四、通过进程名杀死进程" class="headerlink" title="四、通过进程名杀死进程"></a>四、通过进程名杀死进程</h2><p>如果已知需要杀死的进程名，也可以使用以下命令杀死该进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskkill /f /im 进程名</span><br></pre></td></tr></table></figure>

<p>其中，“进程名”是需要杀死的进程名。参数&#x2F;f表示强制终止该进程。</p>
<p>执行该命令后，该进程将会被强制终止。</p>
<h2 id="五、通过批处理批量杀死进程"><a href="#五、通过批处理批量杀死进程" class="headerlink" title="五、通过批处理批量杀死进程"></a>五、通过批处理批量杀死进程</h2><p>如果需要批量杀死多个进程，可以使用批处理脚本来实现。以下是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">set port=8080</span><br><span class="line">set count=0</span><br><span class="line"></span><br><span class="line">for /f &quot;tokens=5 delims= &quot; %%a in (&#x27;netstat -ano ^| findstr :%port%&#x27;) do (</span><br><span class="line">    set /a count+=1</span><br><span class="line">    set pid[!count!]=%%a</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">for /l %%i in (1, 1, %count%) do (</span><br><span class="line">    echo Killing process with pid !pid[%%i]!</span><br><span class="line">    taskkill /f /pid !pid[%%i]!</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>该脚本通过查找端口号为8080的进程，并将对应的PID保存在数组中。然后依次遍历数组，杀死对应的进程。</p>
<h2 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h2><p>在杀死进程时，请注意以下事项：</p>
<ul>
<li>请确保只杀死不需要的进程，不要随意杀死系统内部的重要进程。</li>
<li>杀死进程将会导致正在进行的任务被强制终止，请确保没有重要数据或任务正在进行。</li>
<li>请谨慎使用批处理脚本等批量操作方式，以免误伤有用进程。</li>
</ul>
<p>参考链接：<a href="https://www.python100.com/html/Q04KL23XP62J.html">https://www.python100.com/html/Q04KL23XP62J.html</a></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>服务器部署</tag>
        <tag>开发技能</tag>
      </tags>
  </entry>
  <entry>
    <title>网页管理系统&amp;小程序部署记录【开发&gt;&gt;&gt;生产】</title>
    <url>/2023/07/10/management-system-and-mini-program/</url>
    <content><![CDATA[<p>整个六月都扑在一个政策搜索小程序项目上，项目包括网页管理系统和小程序两部分，网页管理系统用于上传现有政策，小程序端纯做展示和搜索功能。</p>
<p>网页管理系统包括前后端，使用行内脚手架开发，小程序使用百度低代码平台完成页面开发及接口交互。</p>
<span id="more"></span>

<h2 id="一、网页管理系统"><a href="#一、网页管理系统" class="headerlink" title="一、网页管理系统"></a>一、网页管理系统</h2><hr>
<h3 id="1-后端"><a href="#1-后端" class="headerlink" title="1.后端"></a>1.后端</h3><ol>
<li><p>安装maven至本地，本次下载的是maven3.9.3；</p>
</li>
<li><p>使用IDEA打开后端项目代码，在设置中将maven的home path、settings file、repository设置为本地文件和路径；</p>
</li>
<li><p>在项目maven的lifecycle中双击install，将自动下载项目所依赖的包到本地repository；</p>
</li>
<li><p>运行项目，查看报错模块，注释掉不起作用的函数；</p>
</li>
<li><p>点击maven的lifecycle中的package即可打包，路径为target文件夹下的jar包；</p>
</li>
<li><p>运行命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.找到jar所在</span><br><span class="line">cd /home/cloud/qp</span><br><span class="line"></span><br><span class="line">1.查找目标进程值</span><br><span class="line">ps -ef|grep java</span><br><span class="line"></span><br><span class="line">2.杀掉java进程</span><br><span class="line">kill -9 目标进程值</span><br><span class="line"></span><br><span class="line">3.启动项目</span><br><span class="line">    方法一：</span><br><span class="line">    nohup java -jar XXXXXX-service-1.0.0.jar —server.port=9099 &gt;nohup.out 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">    方法二：（调用application.yml文件中默认的启动方式）</span><br><span class="line">    java -jar xxxxxx.jar  --server.port = &lt;端口号&gt;</span><br><span class="line"></span><br><span class="line">    方法三：</span><br><span class="line">    1）复制go.sh文件到项目文件夹下</span><br><span class="line">    2）启动语句：sh ./go.sh XXXXXXX-service prod &lt;端口号&gt;</span><br><span class="line"></span><br><span class="line">4.查看日志</span><br><span class="line">tail -1000f nohup.out</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-前端"><a href="#2-前端" class="headerlink" title="2.前端"></a>2.前端</h3><ol>
<li>使用VScode打开前端项目代码，使用node -v查看node版本，确保和开发环境使用的node大版本一致，因为每个版本拉取的依赖包不一致，会使项目存在版本差，导致项目报错；</li>
<li>可使用npm -v再查看下npm的版本，理论上两者版本一致；</li>
<li>使用npm install下载项目所依赖的外部包，会下载到项目的node_modules文件夹中；</li>
<li>使用npm run local本地化运行项目，成功打开即可；</li>
<li>打包使用npm run build:prod命令，路径为dist文件夹下的所有文件；</li>
</ol>
<h2 id="二、小程序"><a href="#二、小程序" class="headerlink" title="二、小程序"></a>二、小程序</h2><hr>
<ol>
<li>使用百度低代码平台画页面，导入API并测试，可在开发环境联动本地数据进行调试；</li>
<li>待第一步完成，页面、功能、数据测试完毕后，同样的项目导出，重命名为发布版本进行调试，实际上本地开发环境和外网生产环境存在太多不一致；</li>
<li>灵活使用postman测试后端接口，很多时候数据无法返回就是后端接口有问题需要改造；</li>
<li>报错及时查看后端代码，调整相应的返回接口；</li>
</ol>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>网页管理系统</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的Markdown指令</title>
    <url>/2019/03/26/markdown-daily-used/</url>
    <content><![CDATA[<p>Markdown是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML标记语言来说，Markdown可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p>
<span id="more"></span>
<p>markdown的优点：</p>
<ul>
<li>语法简单</li>
<li>更专注内容而非排版，排版只是为了更清楚的展现内容</li>
<li>md轻松转换html及pdf，网络友好</li>
</ul>
<h3 id="1-一级标题"><a href="#1-一级标题" class="headerlink" title="1.一级标题"></a>1.一级标题</h3><pre><code>使用一个井号键#开头，将文字跟在其后，即为一级标题。
例子：#一级标题
</code></pre>
<h3 id="2-二级标题"><a href="#2-二级标题" class="headerlink" title="2.二级标题"></a>2.二级标题</h3><pre><code>使用两个井号键##开头，将文字跟在其后，即为二级标题。
例子：##二级标题
</code></pre>
<h3 id="3-三级标题"><a href="#3-三级标题" class="headerlink" title="3.三级标题"></a>3.三级标题</h3><pre><code>使用三个井号键###开头，将文字跟在其后，即为三级标题。
例子：###三级标题
</code></pre>
<h3 id="4-列表"><a href="#4-列表" class="headerlink" title="4.列表"></a>4.列表</h3><pre><code>- 列表1
- 列表2
   a 这是第一个子列表
   b 这是第二个子列表
- 列表3
</code></pre>
<h3 id="5-链接"><a href="#5-链接" class="headerlink" title="5.链接"></a>5.链接</h3><pre><code> [vikeezan首页](http://www.vikeezan.club/)
 其中[]内的是在页面上显示的文字，后面()内的则是该文字所连接到的网址。
</code></pre>
<h3 id="6-图片"><a href="#6-图片" class="headerlink" title="6.图片"></a>6.图片</h3><pre><code>  ![vikeezan](https://tvax3.sinaimg.cn/crop.0.0.400.400.180/d713f9aely8frntmxyzwgj20b40b4abl.jpg)
  其中[]内存放的是图片的代称，()内的是图片的地址，文件可以是本地的，也可以是在线的。
</code></pre>
<h3 id="7-斜体"><a href="#7-斜体" class="headerlink" title="7.斜体"></a>7.斜体</h3><pre><code>在一对星号**中间填入文字，文字即变为斜体。
例子：*这里是斜体*
</code></pre>
<h3 id="8-粗体"><a href="#8-粗体" class="headerlink" title="8.粗体"></a>8.粗体</h3><pre><code>将四个星号****分为两组，两两为一组，在两组中间填入文字，文字即变为粗体。
例子：**这里是粗体**
</code></pre>
<h3 id="9-单行代码"><a href="#9-单行代码" class="headerlink" title="9.单行代码"></a>9.单行代码</h3><pre><code>在``中输入代码，即可在网页上显示为代码块。
例子： `&lt;html&gt;代码块&lt;/html&gt;`
</code></pre>
<h3 id="10-多行代码"><a href="#10-多行代码" class="headerlink" title="10.多行代码"></a>10.多行代码</h3><pre><code>将六个``````平分为两组，在两组图标中间输入我们的多行代码，即可在网页中显示为多行代码块。
例子：
    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;我是标题&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;//多行代码</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="11-引用内容"><a href="#11-引用内容" class="headerlink" title="11.引用内容"></a>11.引用内容</h3><pre><code>在&gt;后加上文字，即可将文段表现为引用部分。
例子： &gt;以下内容为引用：
</code></pre>
<h3 id="12-上下分割线"><a href="#12-上下分割线" class="headerlink" title="12.上下分割线"></a>12.上下分割线</h3><pre><code>用---即可打印出分隔上下文的分割线。
例子：---
</code></pre>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式基础知识点</title>
    <url>/2025/03/19/regular-expressions-basic-knowledge/</url>
    <content><![CDATA[<p>正则表达式是用于匹配、查找和操作文本的强大工具，通过定义特定模式来描述文本规则。</p>
<h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><h3 id="（一）字符匹配"><a href="#（一）字符匹配" class="headerlink" title="（一）字符匹配"></a>（一）字符匹配</h3><ol>
<li><p><strong>普通字符</strong>：直接匹配对应字符本身。例如，正则表达式 <code>abc</code> 能匹配字符串 “abc”，因为它精确匹配了这三个连续的字符。</p>
</li>
<li><p><strong>元字符</strong>：具有特殊含义的字符。例如，<code>.</code> 匹配除换行符 <code>\n</code> 之外的任意单个字符。正则表达式 <code>a.c</code> 可以匹配 “abc”、“a1c”、“a c” 等，只要中间字符是单个任意字符（除 <code>\n</code> 外）。</p>
<span id="more"></span></li>
</ol>
<h3 id="（二）字符类"><a href="#（二）字符类" class="headerlink" title="（二）字符类"></a>（二）字符类</h3><ol>
<li>**方括号 <code>[]</code>**：定义一个字符集合，匹配其中任意一个字符。例如，<code>[abc]</code> 可以匹配 “a”、“b” 或 “c”。还能使用范围表示，如 <code>[a - z]</code> 匹配任意小写字母，<code>[0 - 9]</code> 匹配任意数字。</li>
<li>**否定字符类 <code>[^]</code>**：匹配不在方括号内的任意一个字符。例如，<code>[^abc]</code> 可以匹配除 “a”、“b”、“c” 之外的任何字符。</li>
</ol>
<h3 id="（三）数量限定符"><a href="#（三）数量限定符" class="headerlink" title="（三）数量限定符"></a>（三）数量限定符</h3><ol>
<li>**<code>\*</code>**：匹配前面的元素零次或多次。例如，<code>a*</code> 可以匹配空字符串，也可以匹配 “a”、“aa”、“aaa” 等任意多个 “a” 组成的字符串。</li>
<li>**<code>+</code>**：匹配前面的元素一次或多次。例如，<code>a+</code> 至少匹配一个 “a”，能匹配 “a”、“aa”、“aaa” 等，但不能匹配空字符串。</li>
<li>**<code>?</code>**：匹配前面的元素零次或一次。例如，<code>a?</code> 可以匹配空字符串或 “a”。</li>
<li>**<code>&#123;n&#125;</code>**：匹配前面的元素恰好 <code>n</code> 次。例如，<code>a&#123;3&#125;</code> 只能匹配 “aaa”。</li>
<li>**<code>&#123;n,&#125;</code>**：匹配前面的元素至少 <code>n</code> 次。例如，<code>a&#123;3,&#125;</code> 能匹配 “aaa”、“aaaa”、“aaaaa” 等。</li>
<li>**<code>&#123;n,m&#125;</code>**：匹配前面的元素至少 <code>n</code> 次，最多 <code>m</code> 次。例如，<code>a&#123;2,4&#125;</code> 可以匹配 “aa”、“aaa”、“aaaa”。</li>
</ol>
<h2 id="二、边界匹配"><a href="#二、边界匹配" class="headerlink" title="二、边界匹配"></a>二、边界匹配</h2><ol>
<li>**<code>^</code>**：匹配字符串的开头。例如，<code>^abc</code> 只会匹配以 “abc” 开头的字符串，如 “abcdef”，而不会匹配 “defabc”。</li>
<li>**<code>$</code>**：匹配字符串的结尾。例如，<code>abc$</code> 只会匹配以 “abc” 结尾的字符串，如 “defabc”，而不会匹配 “abcdef”。</li>
<li>**<code>\b</code>**：匹配单词边界，即单词和非单词字符的分界处。例如，<code>\bcat\b</code> 可以匹配 “the cat is here” 中的 “cat”，但不会匹配 “category” 中的 “cat”。</li>
</ol>
<h2 id="三、分组与捕获"><a href="#三、分组与捕获" class="headerlink" title="三、分组与捕获"></a>三、分组与捕获</h2><ol>
<li>**分组 <code>()</code>**：将多个字符作为一个整体进行操作。例如，<code>(ab)+</code> 表示 “ab” 整体出现一次或多次，可以匹配 “ab”、“abab”、“ababab” 等。</li>
<li><strong>捕获组</strong>：括号内的表达式会被捕获，可以在后续通过索引（从 1 开始）来引用。例如，对于正则表达式 <code>(a)(b)</code>，在匹配 “ab” 后，<code>group(1)</code> 会返回 “a”，<code>group(2)</code> 会返回 “b”。</li>
</ol>
<h2 id="四、示例分析"><a href="#四、示例分析" class="headerlink" title="四、示例分析"></a>四、示例分析</h2><p>假设要从字符串 “USD:352677,33.00” 中提取出 “USD” 和 “352677,33.00” 两部分，使用正则表达式 <code>([A-Z]&#123;3&#125;):(\\d&#123;1,3&#125;(,\\d&#123;3&#125;)*\\.\\d&#123;2&#125;)</code>。</p>
<ol>
<li>**<code>([A-Z]&#123;3&#125;)</code>**：这是第一个捕获组，<code>[A-Z]</code> 表示所有大写字母的字符类，<code>&#123;3&#125;</code> 限定前面的字符类要出现 3 次，所以它会匹配到 “USD” 这样的三位大写字母组合，通过 <code>group(1)</code> 可获取 “USD”。</li>
<li>**<code>:</code>**：匹配字符串中的冒号。</li>
<li>**<code>(\\d&#123;1,3&#125;(,\\d&#123;3&#125;)\*\\.\\d&#123;2&#125;)</code>**：这是第二个捕获组，<code>\\d&#123;1,3&#125;</code> 匹配金额整数部分开头的 1 到 3 位数字，<code>(,\\d&#123;3&#125;)*</code> 匹配可能存在的千分位分隔符及后续 3 位数字，<code>*</code> 表示可以有零个或多个这样的组合，<code>\\.\\d&#123;2&#125;</code> 匹配小数点及后面两位数字。整体匹配 “352677,33.00” 这样格式的金额，通过 <code>group(2)</code> 可获取该金额字符串。</li>
</ol>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>java开发</tag>
      </tags>
  </entry>
  <entry>
    <title>后端管理系统部署操作手册(Linux CentOS7.5)</title>
    <url>/2023/02/28/website-build-notes/</url>
    <content><![CDATA[<p>兄弟分行做了一个客户信息管理系统，架构是后台管理系统+小程序的配置。后台管理系统即一个网站的部署，小程序使用了低码平台开发，可以远程推送在手机上测试。本文档主要用于网站部署过程的记录。</p>
<span id="more"></span>

<h2 id="一、服务器基础配置"><a href="#一、服务器基础配置" class="headerlink" title="一、服务器基础配置"></a>一、服务器基础配置</h2><h3 id="1-Java11安装"><a href="#1-Java11安装" class="headerlink" title="1. Java11安装"></a>1. Java11安装</h3><ol>
<li><p>下载安装包：<a href="https://www.oracle.com/java/technologies/downloads/#java11">https://www.oracle.com/java/technologies/downloads/#java11</a></p>
<p>安装包名称：jdk-11.0.18_linux-x64_bin.tar.gz</p>
</li>
<li><p>上传JDK至云服务器：&#x2F;usr&#x2F;local</p>
</li>
<li><p>解压JDK：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建目录</span><br><span class="line">mkdir /usr/local/java</span><br><span class="line"></span><br><span class="line"># 解压文件到指定目录（查看是否有lib、bin文件夹）</span><br><span class="line">tar -zxvf ./jdk-11.0.18_linux-x64_bin.tar.gz -C /usr/local/java</span><br><span class="line"></span><br><span class="line">#删除安装包</span><br><span class="line">rm -f jdk-11.0.18_linux-x64_bin.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置java的环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打开配置文件</span><br><span class="line">vi /etc/profile</span><br><span class="line"> </span><br><span class="line">#点击i进入编辑模式，在文件末尾添加</span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk-11.0.18</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib/</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line">#按Esc键退出编辑，最后输入 :wq 保存编辑，并回车退出（注意有“:”）</span><br><span class="line"></span><br><span class="line"># 刷新环境变量</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证java是否安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">成功示例：</span><br><span class="line">java version &quot;11.0.18&quot; 2023-01-17 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.18+9-LTS-195)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.18+9-LTS-195, mixed mode)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建软链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建软链接</span><br><span class="line">ln -s /usr/local/java/jdk-11.0.18/bin/java /usr/bin</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://cloud.tencent.com/developer/article/2080307">https://cloud.tencent.com/developer/article/2080307</a></p>
<p>参考链接：<a href="https://blog.csdn.net/dubhe_zhao/article/details/125387612">https://blog.csdn.net/dubhe_zhao/article/details/125387612</a></p>
</li>
</ol>
<h3 id="2-mysql-安装"><a href="#2-mysql-安装" class="headerlink" title="2.mysql 安装"></a>2.mysql 安装</h3><ol>
<li><p>从官网下载用于Linux的Mysql安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://cdn.mysql.com/archives/mysql-8.0/mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xvf mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz </span><br></pre></td></tr></table></figure>
</li>
<li><p>移动解压后的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv mysql-8.0.19-linux-glibc2.12-x86_64 /usr/local/mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>在&#x2F;usr&#x2F;local&#x2F;mysql目录下新建data文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/mysql/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改mysql配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入配置文件</span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line">#以下为添加内容：</span><br><span class="line">[mysqld]</span><br><span class="line">datadir=/usr/local/mysql/data</span><br><span class="line">port=3306</span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">symbolic-links=0</span><br><span class="line">max_connections=600</span><br><span class="line">innodb_file_per_table=1</span><br><span class="line">log-error=/usr/local/mysql/data/error.log</span><br><span class="line">lower_case_table_names=1</span><br><span class="line"># skip-grant-tables</span><br><span class="line">#</span><br><span class="line"># include all files from the config directory</span><br><span class="line"></span><br><span class="line">#esc键退出，输入 :wq 并回车</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改mysql目录下所有的目录及文件夹所属的用户组和用户，以及权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R mysql:mysql /usr/local/mysql</span><br><span class="line">chmod -R 755 /usr/local/mysql</span><br></pre></td></tr></table></figure>

<p>如报错：chown: invalid user: ‘mysql:mysql’</p>
<p>执行以下语句之后，再重新授权：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方法一：</span><br><span class="line">chattr -ia /etc/passwd</span><br><span class="line">chattr -ia /etc/group</span><br><span class="line">chattr -ia /etc/shadow</span><br><span class="line">chattr -ia /etc/gshadow</span><br><span class="line">yum install mysql-server</span><br><span class="line"></span><br><span class="line">#方法二：</span><br><span class="line">useradd -d /var/lib/mysql mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装并初始化mysql,务必记住初始化输出日志末尾的密码（数据库管理员临时密码）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql/bin</span><br><span class="line">./mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试启动mysql服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/mysql/support-files/mysql.server start</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加软连接，并重启mysql服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql</span><br><span class="line">ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果root用户的密码遗失，需重置。因后端密码写死，密码需设置为固定密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入配置文件</span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line">#设置mysql免密</span><br><span class="line">skip-grant-tables</span><br><span class="line"></span><br><span class="line">#退出编辑，重启mysql</span><br><span class="line">service mysql restart</span><br><span class="line"></span><br><span class="line">#进入mysql数据库：</span><br><span class="line">[root@VM-4-2-centos bin]# mysql</span><br><span class="line"></span><br><span class="line">#切换为mysql</span><br><span class="line">mysql&gt;use mysql;</span><br><span class="line"></span><br><span class="line">#如果更新密码时报错：ERROR 1396 (HY000): Operation ALTER USER failed for &#x27;root&#x27;@&#x27;%&#x27;</span><br><span class="line">mysql&gt; update user set host = &#x27;%&#x27; where host = &#x27;localhost&#x27; and user = &#x27;root&#x27;;</span><br><span class="line"></span><br><span class="line">#刷新权限：</span><br><span class="line">mysql&gt;flush privileges;</span><br><span class="line"></span><br><span class="line">#设置root用户新密码：</span><br><span class="line">mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;new_passowrd&#x27;;</span><br><span class="line"></span><br><span class="line">#刷新权限：</span><br><span class="line">mysql&gt;flush privileges;</span><br><span class="line"></span><br><span class="line">#退出mysql</span><br><span class="line">mysql&gt;exit;</span><br><span class="line"></span><br><span class="line">#进入配置文件</span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line">#设置mysql需要密码：</span><br><span class="line"># skip-grant-tables</span><br><span class="line"></span><br><span class="line">#退出编辑，重启mysql</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>

<p>整体流程参考：<a href="https://blog.csdn.net/Box_clf/article/details/124599166">https://blog.csdn.net/Box_clf/article/details/124599166</a></p>
<p>设置密码报错参考：<a href="https://www.cnblogs.com/223zhp/p/16208226.html">https://www.cnblogs.com/223zhp/p/16208226.html</a></p>
</li>
<li><p>开启服务器的3306防火墙规则；</p>
</li>
<li><p>开启mysql8.0的远程连接功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入数据库中</span><br><span class="line">mysql -u root -p &#x27;new_passowrd&#x27;</span><br><span class="line"></span><br><span class="line">#切换数据库</span><br><span class="line">use mysql;</span><br><span class="line"></span><br><span class="line">#开启root用户远程访问权限：</span><br><span class="line">GRANT ALL ON *.* TO &#x27;root&#x27;@&#x27;%&#x27;;</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;你的密码&#x27;;</span><br><span class="line"></span><br><span class="line">#刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line">#退出mysql</span><br><span class="line">exit;</span><br><span class="line"></span><br><span class="line">#重启mysql</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用navicat远程连接mysql数据库，新建数据库sxh:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置：字符集 utf8mb4，排序规则 utf8mb4_0900_ai_ci；</span><br></pre></td></tr></table></figure>
</li>
<li><p>迁移表结构及数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.右击连接名：shfruit；</span><br><span class="line">2.选择“运行SQL文件”；</span><br><span class="line">3.文件选择目标文件，编码默认UTF-8；</span><br><span class="line">4.点击“开始”；</span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考链接：<a href="https://cloud.tencent.com/developer/article/2081683">https://cloud.tencent.com/developer/article/2081683</a></p>
<p>参考链接：<a href="https://www.cnblogs.com/nnnyg/p/15609532.html">https://www.cnblogs.com/nnnyg/p/15609532.html</a></p>
<p>参考链接：<a href="https://blog.csdn.net/z15711187787/article/details/124986309">https://blog.csdn.net/z15711187787/article/details/124986309</a></p>
<h3 id="3-Nginx-安装"><a href="#3-Nginx-安装" class="headerlink" title="3.Nginx 安装"></a>3.Nginx 安装</h3><ol>
<li><p>下载源码包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.19.3.tar.gz -P /usr/local</span><br><span class="line">cd /usr/local</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装nginx依赖包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc pcre-devel zlib-devel</span><br><span class="line">  - gcc: 源码编译工具 </span><br><span class="line">  - pcre-devel： nginx url_rewrite 功能提供包 </span><br><span class="line">  - zlib-devel： nginx 压缩功能提供包	</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压nginx源码，并进入源码包:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xf nginx-1.19.3.tar.gz</span><br><span class="line">cd nginx-1.19.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置nginx源码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</span><br><span class="line">    配置目的：</span><br><span class="line">      1）检查环境 是否 满足安装条件     依赖解决</span><br><span class="line">      2）指定安装方式    配置文件   命令文件  各种文件放哪里   开启模块功能【内置模块  三方模块】</span><br><span class="line">      3）指定软件安装在那里</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装nginx:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>nginx的启动及测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置文件测试</span><br><span class="line">/usr/local/nginx/sbin/nginx -t</span><br><span class="line">#启动</span><br><span class="line">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">#停止</span><br><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">#重载</span><br><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">#杀掉nginx</span><br><span class="line">/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line">使用浏览器访问nginx默认网站</span><br><span class="line"> [root@zutuanxue ~]# http://服务器对应IP</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>nginx的启动及测试：</p>
<p>参考链接：<a href="https://cloud.tencent.com/developer/article/2108431">https://cloud.tencent.com/developer/article/2108431</a></p>
</li>
</ol>
<h2 id="二、系统前后端部署"><a href="#二、系统前后端部署" class="headerlink" title="二、系统前后端部署"></a>二、系统前后端部署</h2><h3 id="1-后端部署"><a href="#1-后端部署" class="headerlink" title="1.后端部署"></a>1.后端部署</h3><ol>
<li><p>新建 &#x2F;usr&#x2F;local&#x2F;jar 文件夹；</p>
</li>
<li><p>将投产的jar包复制到该目录下；</p>
</li>
<li><p>将自动运行脚本 start.sh 文件复制到该目录下；</p>
</li>
<li><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/jar </span><br><span class="line">./start.sh</span><br><span class="line"></span><br><span class="line">#若无权限则执行 chmod u+x start.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-前端部署"><a href="#2-前端部署" class="headerlink" title="2.前端部署"></a>2.前端部署</h3><ol>
<li>根目录下新建&#x2F;web&#x2F;mercury-sxh-service-web-prod&#x2F;文件夹</li>
<li>前端打包dist文件部署至&#x2F;web&#x2F;mercury-sxh-service-web-prod&#x2F;</li>
<li>低代码小程序的前端文件部署至&#x2F;web&#x2F;static&#x2F;files</li>
</ol>
<h3 id="3-nginx配置"><a href="#3-nginx配置" class="headerlink" title="3.nginx配置"></a>3.nginx配置</h3><p>按照示例文件进行配置，主要是域名及默认跳转路径的调整。</p>
<p><a href="https://blog.csdn.net/lin5188230/article/details/124009508">https://blog.csdn.net/lin5188230/article/details/124009508</a></p>
<p><a href="https://blog.csdn.net/weixin_41709748/article/details/127604499">https://blog.csdn.net/weixin_41709748/article/details/127604499</a></p>
<h3 id="三、疑难杂症报错记录"><a href="#三、疑难杂症报错记录" class="headerlink" title="三、疑难杂症报错记录"></a>三、疑难杂症报错记录</h3><p>1.装了四五台服务器，突然遇到这个错误，真滴绝，找半天不知道咋解决，记录一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#报错日志：</span><br><span class="line">Caused by: java.lang.reflect.InvocationTargetException: null</span><br><span class="line">	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)</span><br><span class="line">	at java.desktop/sun.font.FontManagerFactory$1.run(FontManagerFactory.java:84)</span><br><span class="line">	... 139 common frames omitted</span><br><span class="line">Caused by: java.lang.NullPointerException: null</span><br><span class="line">	at java.desktop/sun.awt.FontConfiguration.getVersion(FontConfiguration.java:1262)</span><br><span class="line">	at java.desktop/sun.awt.FontConfiguration.readFontConfigFile(FontConfiguration.java:225)</span><br><span class="line">	at java.desktop/sun.awt.FontConfiguration.init(FontConfiguration.java:107)</span><br><span class="line">	at java.desktop/sun.awt.X11FontManager.createFontConfiguration(X11FontManager.java:719)</span><br><span class="line">	at java.desktop/sun.font.SunFontManager$2.run(SunFontManager.java:379)</span><br><span class="line">	at java.base/java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">	at java.desktop/sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:324)</span><br><span class="line">	at java.desktop/sun.awt.FcFontManager.&lt;init&gt;(FcFontManager.java:35)</span><br><span class="line">	at java.desktop/sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:56)</span><br><span class="line">	... 144 common frames omitted</span><br><span class="line">	</span><br><span class="line">#解决方案：</span><br><span class="line">yum -y install fontconfig</span><br><span class="line">fc-cache</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>服务器部署</tag>
      </tags>
  </entry>
</search>
