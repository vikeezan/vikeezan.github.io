<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EP01-常用的Markdown指令</title>
    <url>/2019/03/26/EP01-markdown-daily-used/</url>
    <content><![CDATA[<p>Markdown是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML标记语言来说，Markdown可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p>
<span id="more"></span>
<p>markdown的优点：</p>
<ul>
<li>语法简单</li>
<li>更专注内容而非排版，排版只是为了更清楚的展现内容</li>
<li>md轻松转换html及pdf，网络友好</li>
</ul>
<h3 id="1-一级标题"><a href="#1-一级标题" class="headerlink" title="1.一级标题"></a>1.一级标题</h3><pre><code>使用一个井号键#开头，将文字跟在其后，即为一级标题。
例子：#一级标题
</code></pre>
<h3 id="2-二级标题"><a href="#2-二级标题" class="headerlink" title="2.二级标题"></a>2.二级标题</h3><pre><code>使用两个井号键##开头，将文字跟在其后，即为二级标题。
例子：##二级标题
</code></pre>
<h3 id="3-三级标题"><a href="#3-三级标题" class="headerlink" title="3.三级标题"></a>3.三级标题</h3><pre><code>使用三个井号键###开头，将文字跟在其后，即为三级标题。
例子：###三级标题
</code></pre>
<h3 id="4-列表"><a href="#4-列表" class="headerlink" title="4.列表"></a>4.列表</h3><pre><code>- 列表1
- 列表2
   a 这是第一个子列表
   b 这是第二个子列表
- 列表3
</code></pre>
<h3 id="5-链接"><a href="#5-链接" class="headerlink" title="5.链接"></a>5.链接</h3><pre><code> [vikeezan首页](http://www.vikeezan.club/)
 其中[]内的是在页面上显示的文字，后面()内的则是该文字所连接到的网址。
</code></pre>
<h3 id="6-图片"><a href="#6-图片" class="headerlink" title="6.图片"></a>6.图片</h3><pre><code>  ![vikeezan](https://tvax3.sinaimg.cn/crop.0.0.400.400.180/d713f9aely8frntmxyzwgj20b40b4abl.jpg)
  其中[]内存放的是图片的代称，()内的是图片的地址，文件可以是本地的，也可以是在线的。
</code></pre>
<h3 id="7-斜体"><a href="#7-斜体" class="headerlink" title="7.斜体"></a>7.斜体</h3><pre><code>在一对星号**中间填入文字，文字即变为斜体。
例子：*这里是斜体*
</code></pre>
<h3 id="8-粗体"><a href="#8-粗体" class="headerlink" title="8.粗体"></a>8.粗体</h3><pre><code>将四个星号****分为两组，两两为一组，在两组中间填入文字，文字即变为粗体。
例子：**这里是粗体**
</code></pre>
<h3 id="9-单行代码"><a href="#9-单行代码" class="headerlink" title="9.单行代码"></a>9.单行代码</h3><pre><code>在``中输入代码，即可在网页上显示为代码块。
例子： `&lt;html&gt;代码块&lt;/html&gt;`
</code></pre>
<h3 id="10-多行代码"><a href="#10-多行代码" class="headerlink" title="10.多行代码"></a>10.多行代码</h3><pre><code>将六个``````平分为两组，在两组图标中间输入我们的多行代码，即可在网页中显示为多行代码块。
例子：
    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">  &lt;title&gt;我是标题&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;//多行代码</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="11-引用内容"><a href="#11-引用内容" class="headerlink" title="11.引用内容"></a>11.引用内容</h3><pre><code>在&gt;后加上文字，即可将文段表现为引用部分。
例子： &gt;以下内容为引用：
</code></pre>
<h3 id="12-上下分割线"><a href="#12-上下分割线" class="headerlink" title="12.上下分割线"></a>12.上下分割线</h3><pre><code>用---即可打印出分隔上下文的分割线。
例子：---
</code></pre>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>EP02-Hexo博客next主题下不蒜子busuanzi访问量统计不显示</title>
    <url>/2019/03/27/EP02-busuanzi-error-solve/</url>
    <content><![CDATA[<p>首先明确在hexo博客的主题配置时，有两个文件经常会用到。一个是blog根目录下的<code>_config.yml</code>文件，我们称其为<strong>站点配置文件</strong>，另一个则是<code>themes\next</code>下的<code>_config.yml</code>文件，我们称其为<strong>主题配置文件</strong>，在主题配置文件内next本身已自集成了一个统计算法，具体的用法如下:</p>
<span id="more"></span>

<p>打开<strong>主题配置文件</strong>，建议用Sublime Text打开，可以使用<code>ctrl+f</code>快捷键，输入<code>busuanzi</code>,你会看到以下代码:（V5版本)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: false</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; </span><br><span class="line">  site_uv_footer: </span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">  site_pv_footer: </span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">  page_pv_footer: ```</span><br><span class="line">（v7版本）</span><br></pre></td></tr></table></figure>
<p>busuanzi_count:<br>  enable: false<br>  total_visitors: true<br>  total_visitors_icon: user<br>  total_views: true<br>  total_views_icon: eye<br>  post_views: true<br>  post_views_icon: eye&#96;&#96;&#96;<br>两个版本的算法虽然在具体细节上有所不同，但总的来说大同小异，使用方法都是将<code>enable: false</code>语句更改为<code>enable: true</code>，改完之后就可以在网站底部看到浏览量已经显示出来了。</p>
<p>这时v5版本的用户可能会发现浏览量依旧显示不出来，打开控制台查看发现是因为<code>不蒜子</code>的js文件找不到所以出错了，据<code>不蒜子</code>的作者<a href="http://ibruce.info/2015/04/04/busuanzi/">不蒜子官方网站</a>介绍是原先的域名失效了，所以不得已更换了新的域名。所以现在我们要在js文件里重新引用一下，接下来是解决方法：</p>
<p>简单来讲就是将<code>next</code>主题下<code>不蒜子</code>的js引用文件更改一下即可。我们首先进去blog根目录下的<code>themes</code>文件夹，找到我们在用的<code>next</code>主题文件夹，然后在<code>\layout\_third-party\analytics</code>下找到<code>busuanzi-counter.swig</code>文件，右击用sublime text打开，在该文件下找到如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>将这句话更改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>然后再刷新下页面，就大功告成啦~总的来说解决问题的方法不难，不过不清楚门道的话不知道怎么改，反正我折腾了很久就是了</p>
<h3 id="祝大家建站快乐，少遇坑"><a href="#祝大家建站快乐，少遇坑" class="headerlink" title="祝大家建站快乐，少遇坑~"></a>祝大家建站快乐，少遇坑~</h3>]]></content>
      <categories>
        <category>建站填坑</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>EP03-Hexo多终端管理的搭建流程</title>
    <url>/2019/03/27/EP03-Multi-terminal-management/</url>
    <content><![CDATA[<h2 id="1-原理介绍"><a href="#1-原理介绍" class="headerlink" title="1.原理介绍"></a>1.原理介绍</h2><p>多终端管理的基本思路是将博客在Github网站上分为两个分支来管理：</p>
<ul>
<li>一个是master主分支用于存放博客的静态网站文件（<code>hexo server</code>之后会在本地文件里生成public文件夹，public文件夹内是根据.md生成的html静态网站文件），我们在电脑上更新完博客之后可以<code>hexo deploy</code>到该分支上，平时点进你的网站<a href="https://username.github.io/">https://username.github.io/</a>时看到的内容就是这个分支解析出来的。<span id="more"></span></li>
<li>另一个分支则是hexo副分支（自己起的名字，可以更改），这个分支的作用是保存博客的最新版本，在不同的电脑上pull并新建博客后，push到这个分支上，这样随时都可以找到博客的最新版本，该分支上的更改如果不经过<code>hexo deploy</code>，不会影响到master主分支上的内容。</li>
</ul>
<p><strong>PS：个人建议之前没有接触过git的同学可以先看一下有关git的基础教程，因为没接触过git的同学瞎用指令会把网站搞崩的，别问我为啥知道…这里推荐廖雪峰的课</strong><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰git教程</a></p>
<h2 id="2-搭建流程"><a href="#2-搭建流程" class="headerlink" title="2.搭建流程"></a>2.搭建流程</h2><p>1.创建仓库，<a href="https://username.github.io/">https://username.github.io/</a>。其中的<strong>username</strong>要由你自己定义，要和你Github注册的用户名保持一致;<br>2.创建两个分支，master和hexo。这一步不用手动创建，后面有指令会自动创建hexo分支的；<br>3.设置hexo为默认分支。因为我们只需要手动管理这个分支上的网站文件，设置方法为项目右上角setting里的branch选项卡，将其中的默认分支更改为hexo即可；<br>4.在第二台电脑上使用git clone <a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#117;&#x62;&#46;&#99;&#x6f;&#109;">&#x67;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#117;&#x62;&#46;&#99;&#x6f;&#109;</a>:username&#x2F;username.github.io.git拷贝仓库；<br>5.在本地的与Github相连的<a href="https://username.github.io/">https://username.github.io/</a>文件夹下右键使用Git Bash依次执行<code>npm install -g hexo-cli </code>安装hexo、<code>hexo init</code>初始化hexo、<code>npm install hexo-deployer-git --save</code>让hexo知道你要把blog部署在哪一个位置。这三条指令完成后当前分支应显示为hexo；<br>6.修改博客站点配置文件<code>_config.yml</code>中的deploy参数，将branch的参数改为master；<br>7.依次执行<code>git add .</code>添加所有文件到缓存区、<code>git commit -m “…”</code>提交缓存区的文件同时增添备注、<code>git push origin hexo</code>将更改的内容push到github的hexo分支进行备份；<br>8.执行<code>hexo g -d</code>生成网站并部署到Github上。<br>经过以上操作之后，我们的master分支用于存放网站的静态文件，hexo分支用于存放网站的原始文件，井水不犯河水，简直太完美了有没有！</p>
<h3 id="2-1第一个终端的hexo分支"><a href="#2-1第一个终端的hexo分支" class="headerlink" title="2.1第一个终端的hexo分支"></a>2.1第一个终端的hexo分支</h3><p>在一开始创建博客的电脑上，将本地blog文件夹内必要的hexo文件push到username.github.io的hexo分支上，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init  //初始化本地仓库</span><br><span class="line">git add source //将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件,例如source themes scaffolds _config.yml package.json package-lock.json等。</span><br><span class="line">git commit -m &quot;Blog Source Hexo&quot; //备注这是blog网站最原始的文件</span><br><span class="line">git branch hexo  //新建hexo分支</span><br><span class="line">git checkout hexo  //切换到hexo分支上</span><br><span class="line">git remote add origin git@github.com:yourname/yourname.github.io.git  //将本地与Github项目对接</span><br><span class="line">git push origin hexo  //push到Github项目的hexo分支上</span><br></pre></td></tr></table></figure>
<h3 id="2-2另一终端完成clone复制以及push更新"><a href="#2-2另一终端完成clone复制以及push更新" class="headerlink" title="2.2另一终端完成clone复制以及push更新"></a>2.2另一终端完成clone复制以及push更新</h3><p>在另一个终端更新博客，只需要将Github的hexo分支上的内容克隆到本地，然后再对其进行更改和push更新，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b hexo git@github.com:yourname/yourname.github.io.git  //将Github中hexo分支clone到本地</span><br><span class="line">cd  yourname.github.io  //切换到刚刚clone的文件夹内</span><br><span class="line">npm install -g hexo-cli    //注意！一定要切换到刚刚clone的文件夹内执行，安装hexo</span><br><span class="line">npm install hexo-deployer-git --save //让hexo知道你要把blog部署在哪一个位置</span><br><span class="line">hexo new post &quot;new blog name&quot;   //新建博客并编辑内容</span><br><span class="line">git add source  //经测试每次只要更新source中的文件到Github中即可，因为只是新建了一篇新博客</span><br><span class="line">git commit -m &quot;XX&quot; //对本次修改进行备注</span><br><span class="line">git push origin hexo  //将当前终端的文件更新到Github上的hexo分支上</span><br><span class="line">hexo d -g   //将自己写的博客部署到自己的博客网站上，同时同步Github中的master分支</span><br></pre></td></tr></table></figure>
<h2 id="3-日常的修改流程"><a href="#3-日常的修改流程" class="headerlink" title="3.日常的修改流程"></a>3.日常的修改流程</h2><p>先对本地的博客进行修改，例如增加博客，更改样式等，再将新的内容push到Github的hexo分支上，哭啼的操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin hexo  //先pull云端的hexo分支文件，完成本地与远端的融合</span><br><span class="line">hexo new post &quot; new blog name&quot; //新建博客并编辑内容</span><br><span class="line">git add source</span><br><span class="line">git commit -m &quot;XX&quot;</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>

<p>本文的参考链接：<a href="https://blog.csdn.net/ZmeiXuan/article/details/78339376">https://blog.csdn.net/ZmeiXuan/article/details/78339376</a></p>
]]></content>
      <categories>
        <category>建站填坑</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>多终端搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>EP04-剑指offer——1.二维数组中的查找</title>
    <url>/2019/07/27/EP04-jianzhioffer01/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h3><p>假设选定一个要查找的数字，如果在数组中任意选取一个数字来和该数字作比较，可能会导致下一次要查找的区域发生重叠。为了简化查找过程，我们可以选取每个查找区域右上角数据（左下角数据也可，原理相同）和要查找的数字进行比较。此时只会发生三种情况：</p>
<span id="more"></span>
<ul>
<li>右上角的数字等于要查找的数字。查找过程结束。</li>
<li>右上角的数字大于要查找的数字。根据该二维数组的特征，排除右上角数字所在的列。</li>
<li>右上角的数字小于要查找的数字。同理，排除右上角数字所在的行。</li>
</ul>
<p>重复以上1~3步，如果要查找的数字不在所查找区域的右上角，那么就每一次都排除一行或者一列，逐渐缩小查找范围，直到找到要查找的数字，或者查找结果为空。</p>
<h3 id="3-举例说明"><a href="#3-举例说明" class="headerlink" title="3.举例说明"></a>3.举例说明</h3><img src="/2019/07/27/EP04-jianzhioffer01/%E6%95%B0%E7%BB%84%E4%B8%BE%E4%BE%8B.jpg" class="" title="数组举例">
<img src="/2019/07/27/EP04-jianzhioffer01/%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.jpg" class="" title="查找过程">

<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p><strong>c++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        int rows = array.size();//数组的行序号</span><br><span class="line">        int cols = array[0].size();//数组的列序号</span><br><span class="line">        if(!array.empty() &amp;&amp; rows &gt; 0 &amp;&amp; cols &gt; 0)&#123;//若数组内容非空、行列序号均大于零</span><br><span class="line">            int row = 0;</span><br><span class="line">            int col = cols - 1;//右上角数据的行、列序号</span><br><span class="line">            while(row &lt; rows &amp;&amp; col &gt;= 0)&#123;//当右上角数据存在时</span><br><span class="line">                if(array[row][col] == target)&#123;</span><br><span class="line">                    return true;//若两数相同，查找结束</span><br><span class="line">                &#125;</span><br><span class="line">                else if(array[row][col] &gt; target)&#123;//若右上角数字大于被查找数，行不变，列减少</span><br><span class="line">                    --col;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    ++row;//若右上角数字小于被查找数，行增加，列不变</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;//否则，数组中不存在被查找数，查找失败</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python2.7：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    # array 二维列表</span><br><span class="line">    def Find(self, target, array):</span><br><span class="line">        # write code here</span><br><span class="line">        rows = len(array)</span><br><span class="line">        cols = len(array[0])</span><br><span class="line">        if rows &gt; 0 and cols &gt; 0:</span><br><span class="line">            row = 0</span><br><span class="line">            col = cols - 1</span><br><span class="line">            while row &lt; rows and col &gt;= 0:</span><br><span class="line">                if target == array[row][col]:</span><br><span class="line">                    return True</span><br><span class="line">                elif target &lt; array[row][col]:</span><br><span class="line">                    col -= 1</span><br><span class="line">                else:</span><br><span class="line">                    row += 1</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>EP06-十大经典排序算法</title>
    <url>/2019/07/28/EP06-10-algorithms/</url>
    <content><![CDATA[<h2 id="0-算法概述"><a href="#0-算法概述" class="headerlink" title="0.算法概述"></a><table><tr><td bgcolor=Gold><font size=5>0.算法概述</font></td></tr></table></h2><h3 id="0-1算法分类"><a href="#0-1算法分类" class="headerlink" title="0.1算法分类"></a>0.1算法分类</h3><p>十种常见的排序算法可以分为两大类：</p>
<ul>
<li><font color=#DC143C>比较类排序：</font>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li>
<li><font color=#DC143C>非比较类排序：</font>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。<span id="more"></span>
<img src="/2019/07/28/EP06-10-algorithms/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.jpg" class="" title="排序算法分类"></li>
</ul>
<h3 id="0-2算法时间复杂度比较"><a href="#0-2算法时间复杂度比较" class="headerlink" title="0.2算法时间复杂度比较"></a>0.2算法时间复杂度比较</h3><p>不同的算法在时间和空间上的复杂度各不相同，一般来说，算法所需要的运算空间越小，时间越短，则表明该算法更优。<br>本文涉及的十种经典算法的复杂度如下:</p>
<img src="/2019/07/28/EP06-10-algorithms/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.png" class="" title="十大经典算法复杂度">

<h3 id="0-3算法中的相关概念"><a href="#0-3算法中的相关概念" class="headerlink" title="0.3算法中的相关概念"></a>0.3算法中的相关概念</h3><ul>
<li><b>稳定性：</b> 在a&#x3D;b的情况下，a原本排在b之前，若算法稳定的话，排序之后a依旧在b之前；若算法不稳定，排序之后a可能会出现在b之后。</li>
<li><b>时间复杂度：</b> 指算法对排序数据的总的操作次数。反映当数据个数的n变化时，其操作次数的增减规律。</li>
<li><b>空间复杂度：</b> 指算法在计算机内执行所需的存储空间。反映其随着数据个数n变化的增减规律。</li>
</ul>
<h2 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a><table><tr><td bgcolor=Gold><font size=5>1.冒泡排序（Bubble Sort）</font></td></tr></table></h2><p>冒泡排序的基本思想是：重复比较相邻的两个元素，若顺序错误就将它们的位置交换，直到被排序的所有元素不再需要交换位置时，表明该数列已经排序完成。该算法的名字由来是因为越小的元素会随着排序的进行慢慢“漂浮（冒泡）”到数列的顶端。</p>
<h3 id="1-1算法步骤"><a href="#1-1算法步骤" class="headerlink" title="1.1算法步骤"></a>1.1算法步骤</h3><ul>
<li>比较相邻的两个元素。若第一个比第二个大，则交换位置，将小元素放在前面；</li>
<li>对每一对相邻的元素都执行相同的操作，从开始第一对到最后一对，排序之后，最后一个元素应该是最大的数；</li>
<li>除去最后一个元素，针对所有元素重复1、2两步；</li>
<li>重复1~3步，直到排序完成。<img src="/2019/07/28/EP06-10-algorithms/1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" class="" title="冒泡排序"></li>
</ul>
<h3 id="1-2代码实现"><a href="#1-2代码实现" class="headerlink" title="1.2代码实现"></a>1.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比</span><br><span class="line">                var temp = arr[j+1];        // 元素交换</span><br><span class="line">                arr[j+1] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a><table><tr><td bgcolor=Gold><font size=5>2.选择排序（Selection Sort）</font></td></tr></table></h2><p>选择排序是一种简单直观的排序算法。基本思想是：首先在未排序序列中找到最小（大）的元素，存放到排序序列的起始位置，然后再从剩余的未排序元素中选出最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素都被选择完。</p>
<h3 id="2-1算法步骤"><a href="#2-1算法步骤" class="headerlink" title="2.1算法步骤"></a>2.1算法步骤</h3><p>假设有n个数据，那么可以通过n-1次直接选择排序得到有序结果。具体的算法如下：</p>
<ul>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i&#x3D;1,2,3…n-1)：排序之前的有序区为R[1..i-1]，无序区为R(i..n）。该趟排序从无序区中选择出关键字最小的记录R[k]，将它与无序区的第1个记录R交换，排序之后的新有序区为R[1..i]，新无序区为R[i+1..n]；</li>
<li>n-1次排序结束，数组最终排序完成。<img src="/2019/07/28/EP06-10-algorithms/2.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" class="" title="选择排序"></li>
</ul>
<h3 id="2-2代码实现"><a href="#2-2代码实现" class="headerlink" title="2.2代码实现"></a>2.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数</span><br><span class="line">                minIndex = j;                 // 将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3算法分析"><a href="#2-3算法分析" class="headerlink" title="2.3算法分析"></a>2.3算法分析</h3><p>该算法表现非常稳定，是最稳定的排序算法之一。因为无论什么数据进去都是O(n2)的时间复杂度，所以使用该算法时，数据规模越小越好。好处在于不占用额外的内存空间。理论上讲，选择排序可能是能被最多人想到的排序算法。</p>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a><table><tr><td bgcolor=Gold><font size=5>3.插入排序（Insertion Sort）</font></td></tr></table></h2><p>插入排序是一种简单直观的排序算法。基本思想是：通过构建有序数列，对于未排序的数据，在已排序的序列中从后向前扫描，找到相应位置并插入。</p>
<h3 id="3-1算法步骤"><a href="#3-1算法步骤" class="headerlink" title="3.1算法步骤"></a>3.1算法步骤</h3><p>一般来说，插入排序采用in-place在数组上实现。具体的算法如下：</p>
<ul>
<li>第一个元素可以视为已经被排序；</li>
<li>取出下一个元素，在已排序的元素序列中，从后向前扫描；</li>
<li>若已排序数列中的旧元素大于新元素，则将旧元素移到下一个位置；</li>
<li>重复步骤3，直到找到已排序数列中的旧元素小于或等于新元素的位置；</li>
<li>将新元素插入该位置；</li>
<li>重复步骤2~5。<img src="/2019/07/28/EP06-10-algorithms/3.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" class="" title="插入排序"></li>
</ul>
<h3 id="3-2代码实现"><a href="#3-2代码实现" class="headerlink" title="3.2代码实现"></a>3.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function insertionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var preIndex, current;</span><br><span class="line">    for (var i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - 1;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + 1] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + 1] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3算法分析"><a href="#3-3算法分析" class="headerlink" title="3.3算法分析"></a>3.3算法分析</h3><p>插入算法在实现上通常使用in-place排序，所以只需要O(1)的额外空间，因而在从后向前扫描的过程中，需要反复把已排序元素逐步向后移动位置，为新元素提供插入空间。</p>
<h2 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a><table><tr><td bgcolor=Gold><font size=5>4.希尔排序（Shell Sort）</font></td></tr></table></h2><p>1959年由Shell发明,是第一个突破O(n2)的排序算法，是插入排序的改进版。它和插入排序的不同之处在于，它会优先比较距离较远的元素。所以希尔排序又叫做缩小增量排序。</p>
<h3 id="4-1算法步骤"><a href="#4-1算法步骤" class="headerlink" title="4.1算法步骤"></a>4.1算法步骤</h3><p>将整个待排序的序列分割称为若干子序列，分别进行直接插入排序，具体的算法如下：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li>
<li>按增量序列个数k，对序列进行k次排序；</li>
<li>每次排序根据对应的增量ti，将待排序的数列分割为若干长度为m的子序列，分别对子序列进行直接插入排序。只有当增量因子变为1时，将整个数列作为一整个序列来处理，序列长度即为整个数列的长度。<img src="/2019/07/28/EP06-10-algorithms/4.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" class="" title="希尔排序"></li>
</ul>
<h3 id="4-2代码实现"><a href="#4-2代码实现" class="headerlink" title="4.2代码实现"></a>4.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function shellSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) &#123;</span><br><span class="line">        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span><br><span class="line">        for (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            var j = i;</span><br><span class="line">            var current = arr[i];</span><br><span class="line">            while (j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                 arr[j] = arr[j - gap];</span><br><span class="line">                 j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3算法分析"><a href="#4-3算法分析" class="headerlink" title="4.3算法分析"></a>4.3算法分析</h3><p>希尔序列的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法出自《算法（第4版）》。</p>
<h2 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a><table><tr><td bgcolor=Gold><font size=5>5.归并排序（Merge Sort）</font></td></tr></table></h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是分治法（Divide and Conquer）的一个典型的应用。基本思想是：将已有的子序列合并，得到完全有序的序列。即先让每个子序列有序，再使得子序列段间有序。若将两个有序表合并成为一个有序表，则可以称作2路归并。</p>
<h3 id="5-1算法步骤"><a href="#5-1算法步骤" class="headerlink" title="5.1算法步骤"></a>5.1算法步骤</h3><ul>
<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成为一个最终的有序的序列。<img src="/2019/07/28/EP06-10-algorithms/5.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" class="" title="归并排序"></li>
</ul>
<h3 id="5-2代码实现"><a href="#5-2代码实现" class="headerlink" title="5.2代码实现"></a>5.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mergeSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    if (len &lt; 2) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle = Math.floor(len / 2),</span><br><span class="line">        left = arr.slice(0, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function merge(left, right) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line"></span><br><span class="line">    while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123;</span><br><span class="line">        if (left[0] &lt;= right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"></span><br><span class="line">    while (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-算法分析"><a href="#5-3-算法分析" class="headerlink" title="5.3 算法分析"></a>5.3 算法分析</h3><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但是表现比选择排序要好得多，因为时间复杂度始终为O(nlogn）。代价是需要额外的内存空间。</p>
<h2 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a><table><tr><td bgcolor=Gold><font size=5>6.快速排序（Quick Sort）</font></td></tr></table></h2><p>快速排序的基本思想是：通过一趟排序将待排序的数据分割成为独立的两部分。其中一个部分记录的数据均比另一个部分的数据小，那么可以分别对这两部分的数据继续进行排序，从而达到整个序列有序的目的。</p>
<h3 id="6-1算法步骤"><a href="#6-1算法步骤" class="headerlink" title="6.1算法步骤"></a>6.1算法步骤</h3><p>快速排序使用分治法把一个串(list)分成两个子串(sub-lists)。具体的算法如下：</p>
<ul>
<li>从数列中挑出一个元素，称为“基准”(pivot);</li>
<li>重新排序数列，将数列中比基准值小的数据放在基准前面，比基准值大的数据放在基准后面（相同的数据可以放到任意一边）。在该分区退出之后，该基准就处于数列的中间位置。这个操作称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。<img src="/2019/07/28/EP06-10-algorithms/6.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" class="" title="快速排序"></li>
</ul>
<h3 id="6-2代码实现"><a href="#6-2代码实现" class="headerlink" title="6.2代码实现"></a>6.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function quickSort(arr, left, right) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left = typeof left != &#x27;number&#x27; ? 0 : left,</span><br><span class="line">        right = typeof right != &#x27;number&#x27; ? len - 1 : right;</span><br><span class="line"></span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex-1);</span><br><span class="line">        quickSort(arr, partitionIndex+1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function partition(arr, left ,right) &#123;     // 分区操作</span><br><span class="line">    var pivot = left,                      // 设定基准值（pivot）</span><br><span class="line">        index = pivot + 1;</span><br><span class="line">    for (var i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        if (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - 1);</span><br><span class="line">    return index-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a><table><tr><td bgcolor=Gold><font size=5>7.堆排序（Heap Sort）</font></td></tr></table></h2><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（大于）它的父节点。</p>
<h3 id="7-1算法步骤"><a href="#7-1算法步骤" class="headerlink" title="7.1算法步骤"></a>7.1算法步骤</h3><ul>
<li>将初始待排序数列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时新无序区为(R1,R2,……Rn-1)，新有序区为(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此将当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新无序区为(R1,R2….Rn-2)，新有序区为(Rn-1,Rn)。</li>
<li>不断重复此过程，直到有序区元素个数为n-1，则整个排序过程完成。<img src="/2019/07/28/EP06-10-algorithms/7.%E5%A0%86%E6%8E%92%E5%BA%8F.gif" class="" title="堆排序"></li>
</ul>
<h3 id="7-2代码实现"><a href="#7-2代码实现" class="headerlink" title="7.2代码实现"></a>7.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br><span class="line"></span><br><span class="line">function buildMaxHeap(arr) &#123;   // 建立大顶堆</span><br><span class="line">    len = arr.length;</span><br><span class="line">    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function heapify(arr, i) &#123;     // 堆调整</span><br><span class="line">    var left = 2 * i + 1,</span><br><span class="line">        right = 2 * i + 2,</span><br><span class="line">        largest = i;</span><br><span class="line"></span><br><span class="line">    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (largest != i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function heapSort(arr) &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"></span><br><span class="line">    for (var i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(arr, 0, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a><table><tr><td bgcolor=Gold><font size=5>8.计数排序（Counting Sort）</font></td></tr></table></h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是<strong>有确定范围的整数</strong>。</p>
<h3 id="8-1算法步骤"><a href="#8-1算法步骤" class="headerlink" title="8.1算法步骤"></a>8.1算法步骤</h3><ul>
<li>找出待排序数组中的最大和最小元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<img src="/2019/07/28/EP06-10-algorithms/8.%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" class="" title="计数排序"></li>
</ul>
<h3 id="8-2代码实现"><a href="#8-2代码实现" class="headerlink" title="8.2代码实现"></a>8.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function countingSort(arr, maxValue) &#123;</span><br><span class="line">    var bucket = new Array(maxValue + 1),</span><br><span class="line">        sortedIndex = 0;</span><br><span class="line">        arrLen = arr.length,</span><br><span class="line">        bucketLen = maxValue + 1;</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; arrLen; i++) &#123;</span><br><span class="line">        if (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var j = 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        while(bucket[j] &gt; 0) &#123;</span><br><span class="line">            arr[sortedIndex++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3算法分析"><a href="#8-3算法分析" class="headerlink" title="8.3算法分析"></a>8.3算法分析</h3><p>计数算法是一个稳定的排序算法。当输入的元素是n个0到k之间的整数时，时间复杂度为O(n+k)，空间复杂度也是O(n+k)，它的排序速度快于任何比较排序算法。当k不是很大且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a><table><tr><td bgcolor=Gold><font size=5>9.桶排序（Bucket Sort）</font></td></tr></table></h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键在于这个映射函数。基本思想是：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<h3 id="9-1算法步骤"><a href="#9-1算法步骤" class="headerlink" title="9.1算法步骤"></a>9.1算法步骤</h3><ul>
<li>设定一个定量的数组当做空桶；</li>
<li>遍历输入数据，并且把数据一个个放到对应的桶中；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把已排序的数据拼接起来。<img src="/2019/07/28/EP06-10-algorithms/9.%E6%A1%B6%E6%8E%92%E5%BA%8F.png" class="" title="桶排序"></li>
</ul>
<h3 id="9-2代码实现"><a href="#9-2代码实现" class="headerlink" title="9.2代码实现"></a>9.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length === 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var i;</span><br><span class="line">    var minValue = arr[0];</span><br><span class="line">    var maxValue = arr[0];</span><br><span class="line">    for (i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                // 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                // 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5</span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;</span><br><span class="line">    var buckets = new Array(bucketCount);</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr.length = 0;</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j = 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3算法分析"><a href="#9-3算法分析" class="headerlink" title="9.3算法分析"></a>9.3算法分析</h3><p>桶排序最好情况下的时间复杂度为O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。缺点是相应的空间消耗就会增大。</p>
<h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a><table><tr><td bgcolor=Gold><font size=5>10.基数排序（Radix Sort）</font></td></tr></table></h2><p>基数排序是按照数列的低位先排序（例如个位），然后收集；再按照数列的高位排序（例如十位），然后再收集；以此类推，直到最高位。有时候有些属性有优先级顺序，先按低优先级排序，再按高优先级排序。最后的结果就是高优先级在前，高优先级相同的话则低优先级高的在前。</p>
<h3 id="10-1算法步骤"><a href="#10-1算法步骤" class="headerlink" title="10.1算法步骤"></a>10.1算法步骤</h3><ul>
<li>取得数组中的最大数，并且取得数组的位数；</li>
<li>arr为原始数组，从最低位开始每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）。<img src="/2019/07/28/EP06-10-algorithms/10.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" class="" title="基数排序"></li>
</ul>
<h3 id="10-2代码实现"><a href="#10-2代码实现" class="headerlink" title="10.2代码实现"></a>10.2代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var counter = [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod = 10;</span><br><span class="line">    var dev = 1;</span><br><span class="line">    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</span><br><span class="line">        for(var j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">            if(counter[bucket]==null) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = 0;</span><br><span class="line">        for(var j = 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value = null;</span><br><span class="line">            if(counter[j]!=null) &#123;</span><br><span class="line">                while ((value = counter[j].shift()) != null) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-3算法分析"><a href="#10-3算法分析" class="headerlink" title="10.3算法分析"></a>10.3算法分析</h3><p>1.基数排序是分别排序，分别收集，所以总体上是稳定的。不过基数排序的性能比桶排序差一点，每一次数据的桶分配都需要O(n)的时间复杂度，且分配之后得到的新的数据序列又需要O(n)的时间复杂度。假如待排序的数据可以分为d组，那么基数排序的时间复杂度将是O(d*2n)，当然d要远远小于n，因此基本上还是线性级别的。<br>2.基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>EP05-剑指offer——2.替换空格</title>
    <url>/2019/07/27/EP05-jianzhioffer02/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;拿到字符串之后，很容易想到有两种方式完成替换。第一种：从头到尾遍历，在原字符串的基础上进行替换。这种方式的缺点在于靠后的字符串会多次移动，因此对于含有O（n）个<strong>空格字符</strong>的字符串而言时间复杂度是O（n2）。第二种：创建一个新的字符串，并在其上进行替换。这种方式需要我们自己分配足够的内存空间。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文采用了一种使用<strong>从后向前遍历</strong>实现空格替换的方法，这种方法中所有的字符串只需要移动一次，因此这个算法的时间复杂度为O（n）。总体的算法步骤如下：</p>
<span id="more"></span>
<ul>
<li>先遍历一次字符串，得到字符串中的空格个数，以及插入新字符之前的原字符串长度；</li>
<li>根据第一步的结果，计算出替换完成后新字符串的长度。新字符串长度 &#x3D; 原字符串长度 + 空格个数*2；</li>
<li>给定两个指针a和b，a指向原字符串尾，b指向替换之后的字符串尾。向前移动指针a，逐个把它指向的字符复制到b指向的位置，直到碰到空格，a向前一格，b之前插入字符串”%20”，同时b向前移动3格。</li>
<li>重复第三步，直到a和b指向同一个位置。</li>
</ul>
<h3 id="3-举例说明"><a href="#3-举例说明" class="headerlink" title="3.举例说明"></a>3.举例说明</h3><p>以”We are happy”为例，”We are happy”这个字符串的长度为14（包括结尾符号”\n”），里面有两个空格，因此替换之后字符串的长度是18。我们从字符串的尾部开始复制和替换。首先准备两个指针P1和P2，P1指向原始字符串的末尾，P2指向替换之后的字符串末尾。接下来向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格。碰到第一个空格后，P1向前移动1格，P2位置开始向前插入字符串”%20”，同时P2向前移动3格。</p>
<img src="/2019/07/27/EP05-jianzhioffer02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BE%8B%E5%AD%90.jpg" class="" title="字符串例子">

<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p><strong>c++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	void replaceSpace(char *string,int length)&#123;</span><br><span class="line">    if(string == NULL || length &lt;= 0)</span><br><span class="line">    	return;</span><br><span class="line">    //循环遍历数组，得到字符串的总长，以及空格的个数</span><br><span class="line">    int originLength = 0;</span><br><span class="line">    int numSpace = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while(string[i] != &#x27;\0&#x27;)</span><br><span class="line">    	&#123;</span><br><span class="line">        ++originLength;</span><br><span class="line"></span><br><span class="line">        	if(string[i] == &#x27; &#x27;)</span><br><span class="line">            	++numSpace;</span><br><span class="line"></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    //得到新数组所需的字符串长度</span><br><span class="line">    int newLength = originLength + numSpace*2;//新字符串长度 = 原字符串长度 + 空格个数*2；</span><br><span class="line">    if(newLength &gt;length)</span><br><span class="line">    	return;</span><br><span class="line"></span><br><span class="line">	////检索到空格，就将空格替换为‘%’‘2’‘0’</span><br><span class="line">    int p1 = originLength;</span><br><span class="line">    int p2 = newLength;</span><br><span class="line">    while(p1 &gt;= 0 &amp;&amp; p2 &gt; p1 )&#123;</span><br><span class="line">    	if(string[p1] == &#x27; &#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">        	string[p2--] = &#x27;0&#x27;;</span><br><span class="line">            string[p2--] = &#x27;2&#x27;;</span><br><span class="line">            string[p2--] = &#x27;%&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            string[p2--] = string[p1];</span><br><span class="line">        &#125;</span><br><span class="line">        --p1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python2.7:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    # string指代 源字符串</span><br><span class="line">    def replaceSpace(self, string):</span><br><span class="line">        # write code here</span><br><span class="line">        return string.replace(&#x27; &#x27;, &#x27;%20&#x27;)</span><br></pre></td></tr></table></figure>































]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>EP07-git分布式管理系统常用指令</title>
    <url>/2019/08/01/EP07-git-instructions/</url>
    <content><![CDATA[<p>参考资料：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰git教程</a>)</p>
<h2 id="1-git是什么？"><a href="#1-git是什么？" class="headerlink" title="1.git是什么？"></a>1.git是什么？</h2><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。那什么是版本控制系统？</p>
<blockquote>
<p>如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：<br>想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：</p>
</blockquote>
<span id="more"></span>
<img src="/2019/08/01/EP07-git-instructions/git%E4%BE%8B%E5%AD%90.jpg" class="" title="git例子">

<p>于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？这个软件用起来就应该像这个样子，能记录每次文件的改动：这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。</p>
<h2 id="2-集中式VS分布式"><a href="#2-集中式VS分布式" class="headerlink" title="2.集中式VS分布式"></a>2.集中式VS分布式</h2><p><strong>集中式：</strong><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<img src="/2019/08/01/EP07-git-instructions/%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.jpg" class="" title="集中式管理系统">
<p>缺点：</p>
<ul>
<li>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</li>
<li>而且集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</li>
</ul>
<p><strong>分布式：</strong><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<img src="/2019/08/01/EP07-git-instructions/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.jpg" class="" title="分布式管理系统">
<p>优点：<br>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。</p>
<h2 id="3-创建版本库"><a href="#3-创建版本库" class="headerlink" title="3.创建版本库"></a>3.创建版本库</h2><h3 id="3-1创建版本库"><a href="#3-1创建版本库" class="headerlink" title="3.1创建版本库"></a>3.1创建版本库</h3><ul>
<li>1.选择一个合适的地方，创建一个空目录。pwd命令用于显示当前目录。在下面例子中，这个仓库位于<code>/Users/vikee/learngit</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir learngit</span><br><span class="line">cd learngit</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure></li>
<li>2.通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：<code>git init</code>。瞬间Git就把仓库建好了，而且告诉你这里是一个空的仓库<code>empty Git repository</code>，细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</li>
</ul>
<h3 id="3-2把文件添加到版本库"><a href="#3-2把文件添加到版本库" class="headerlink" title="3.2把文件添加到版本库"></a>3.2把文件添加到版本库</h3><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。<br>假设我们在<code>learngit</code>目录下（子目录也行，因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件）编写了一个readme.txt文件，现在我们要将其上传到版本库中。</p>
<ul>
<li>1.用命令<code>git add</code>告诉Git，把文件添加到仓库，若没有任何显示的话表明添加成功： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure></li>
<li>2.用命令<code>git commit</code>告诉Git，把文件提交到仓库,其中<code>git commit</code>命令的<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。<code>git commit</code>命令执行成功后会告诉你，<code>1 file changed：</code>1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions：</code>插入了两行内容（readme.txt有两行内容）。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line">1 file changed, 2 insertions(+)</span><br><span class="line">create mode 100644 readme.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add file1.txt</span><br><span class="line">git add file2.txt file3.txt</span><br><span class="line">git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure>
<h2 id="4-版本管理"><a href="#4-版本管理" class="headerlink" title="4.版本管理"></a>4.版本管理</h2><h3 id="4-1版本回退"><a href="#4-1版本回退" class="headerlink" title="4.1版本回退"></a>4.1版本回退</h3><p>在你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<ul>
<li><p>1.<code>git log</code>:可以查看提交历史，命令显示从最近到最远的提交日志，以便确定要回退到哪个版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line">    add distributed</span><br></pre></td></tr></table></figure>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数，一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号）,这是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.<code>git reset</code>:回退到之前的版本。在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;想要再返回当前版本时，使用<code>git log</code>指令找到最新版本的提交ID，假设最新版本的提交ID是<code>1094adb...</code>可以使用如下命令返回,版本号没必要写全，前几位就可以了，Git会自动去找，至少前5位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把<code>HEAD</code>从指向<code>append GPL</code>(最新版本)改为指向<code>add distributed</code>（上一版本）。然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
<img src="/2019/08/01/EP07-git-instructions/%E5%9C%B0%E5%9D%80%E6%9B%B4%E6%94%B9%E5%89%8D.png" class="" title="地址更改前">
<img src="/2019/08/01/EP07-git-instructions/%E5%9C%B0%E5%9D%80%E6%9B%B4%E6%94%B9%E5%90%8E.png" class="" title="地址更改后">
</li>
<li><p>3.<code>git reflog</code>：查看命令历史，以便确定要回到未来的哪个版本。当你回退到上一版本退出命令行界面之后，找不到实际上文件最新版本的<code>commit id</code>时,就可以用<code>git reflog</code>找到之后的id。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2工作区和暂存区"><a href="#4-2工作区和暂存区" class="headerlink" title="4.2工作区和暂存区"></a>4.2工作区和暂存区</h3><p><strong>工作区（Working Directory）：</strong><br>在电脑里能看到的目录，比如下面的learngit文件夹就是一个工作区。</p>
<img src="/2019/08/01/EP07-git-instructions/%E5%B7%A5%E4%BD%9C%E5%8C%BA.png" class="" title="工作区">

<p><strong>版本库（Repository）：</strong><br>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。<br>Git的版本库里存了很多东西，其中最重要的就是称为<code>stage</code>（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向master的一个指针叫<code>HEAD</code>。</p>
<img src="/2019/08/01/EP07-git-instructions/%E7%89%88%E6%9C%AC%E5%BA%93.jpg" class="" title="版本库">

<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<ul>
<li>1.用<code>git add</code>文件添加进去，实际上就是把文件修改添加到<strong>暂存区</strong>；</li>
<li>2.用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容<strong>提交到当前分支</strong>。在创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用<code>git status</code>查看一下工作区各个文件的状态。<code>modified</code>表明文件被修改了。<code>Untracked</code>则表明文件是新增的，还未被添加到暂存区中。
</li>
</ul>
<h3 id="4-3管理修改"><a href="#4-3管理修改" class="headerlink" title="4.3管理修改"></a>4.3管理修改</h3><p>为什么Git比其他版本控制系统设计得优秀？因为Git跟踪并管理的是修改，而非文件。</p>
<ul>
<li>1.假设一个文件read.txt增加了一行内容。然后使用<code>git add</code>将文件添加到缓存区。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes.//增加的内容</span><br></pre></td></tr></table></figure></li>
<li>2.在上一步的基础上，我们又修改了文件的内容。然后使用<code>git commit</code>将文件提交到当前分支。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt </span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure>
提交后，再使用<code>git status</code>状态,发现第二次的修改没有更新，只有第一次的修改更新到了当前分支中。我们可以仔细分析一下以上文件修改和提交的过程：第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code>。不难发现第二次修改之后并没有使用<code>git add</code>提交文件到缓存区，所以第一次的修改被提交了，第二次的文件并没有被提交。</li>
<li>3.提交后，使用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别。</li>
</ul>
<h3 id="4-4撤销修改"><a href="#4-4撤销修改" class="headerlink" title="4.4撤销修改"></a>4.4撤销修改</h3><p>修改文件内容后想恢复到上一个版本时。使用<code>git checkout -- file</code>可以丢弃工作区的修改，该指令的意思是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况,总之就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态：</p>
<ul>
<li>1.<code>readme.txt</code>自修改后还<strong>没有被放到暂存区</strong>，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>2.<code>readme.txt</code>已经<strong>添加到暂存区</strong>，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
</ul>
<p><strong>注意：</strong><code>git checkout -- file</code>命令中的–很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，</p>
<p>当文件已经被添加到暂存区，还没有被提交。想要撤回修改可以使用以下两步：</p>
<ul>
<li>1.用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区,<code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	readme.txt</span><br></pre></td></tr></table></figure></li>
<li>2.使用第一步的指令，再用<code>git status</code>查看当前状态，可以发现暂存区是干净的，工作区有修改。那丢弃工作区的修改，可以使用上面方法中的<code>git checkout -- file</code>指令。</li>
</ul>
<h3 id="4-5删除文件"><a href="#4-5删除文件" class="headerlink" title="4.5删除文件"></a>4.5删除文件</h3><ul>
<li>1.一般情况下，通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删除：<code>rm test.txt</code>;</li>
<li>2.这时Git知道你删除了文件，因此，工作区和版本库不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了;</li>
<li>3.现在你有两个选择,一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;另一种情况则是不小心删错了，因为版本库里还有最新的版本，所以可以很轻松地把误删的文件恢复到最新版本：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<strong>注意：</strong><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。<strong>但如果是从来没有被添加到版本库就被删除的文件，是无法恢复的！</strong></li>
</ul>
<h2 id="5-分支管理"><a href="#5-分支管理" class="headerlink" title="5.分支管理"></a>5.分支管理</h2><h3 id="5-1创建与合并分支"><a href="#5-1创建与合并分支" class="headerlink" title="5.1创建与合并分支"></a>5.1创建与合并分支</h3><p>在版本回退里，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的是<strong>当前分支</strong>。</p>
<ul>
<li>1.开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD指</code>向<code>master</code>，就能确定当前分支，以及当前分支的提交点,每次提交，<code>master</code>支都会向前移动一步，这样随着你不断提交，<code>master</code>分支的线也越来越长。<img src="/2019/08/01/EP07-git-instructions/%E5%88%86%E6%94%AF%E6%AD%A5%E9%AA%A41.png" class="" title="分支步骤1"></li>
<li>2.当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上,Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！<img src="/2019/08/01/EP07-git-instructions/%E5%88%86%E6%94%AF%E6%AD%A5%E9%AA%A42.png" class="" title="分支步骤2"></li>
<li>3.从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变。<img src="/2019/08/01/EP07-git-instructions/%E5%88%86%E6%94%AF%E6%AD%A5%E9%AA%A43.png" class="" title="分支步骤3"></li>
<li>4.假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并。<img src="/2019/08/01/EP07-git-instructions/%E5%88%86%E6%94%AF%E6%AD%A5%E9%AA%A44.png" class="" title="分支步骤4"></li>
<li>5.合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，之后就剩下了一条<code>master</code>分支。</li>
</ul>
<p><strong>具体的指令：</strong><br>查看分支：<code>git branch</code>。<code>git branch</code>命令会列出所有分支，当前分支前面会标一个*号</p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h3 id="5-2解决冲突"><a href="#5-2解决冲突" class="headerlink" title="5.2解决冲突"></a>5.2解决冲突</h3><p>当一个文件的不同分支，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p>
<img src="/2019/08/01/EP07-git-instructions/%E5%88%86%E6%94%AF%E5%90%84%E6%9C%89%E4%BF%AE%E6%94%B9.png" class="" title="分支各有修改">
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，Git告诉我们，当前的文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件。解决冲突的方法如下：</p>
<ul>
<li>1.直接查看存在冲突文件的内容,Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></li>
<li>2.我们修改文件之后如下后保存。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure></li>
<li>3.再使用<code>git commit</code>指令将修改提交。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;conflict fixed&quot;</span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure>
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;现在<code>master</code>分支和<code>feature1</code>分支变成了下图所示：<img src="/2019/08/01/EP07-git-instructions/%E5%86%B2%E7%AA%81%E4%BF%AE%E6%94%B9%E4%B9%8B%E5%90%8E.png" class="" title="冲突修改之后"></li>
<li>4.最后，删除feature1分支：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 14096d0).</span><br></pre></td></tr></table></figure>
<strong>注意:</strong><br>用<code>git log --graph</code>命令可以看到分支合并图。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>EP08-剑指offer——3.从尾到头打印链表</title>
    <url>/2019/08/04/EP08-jianzhioffer03/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
</blockquote>
<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;拿到链表之后想要反向输出，最容易想到的方法可能是将指针的指向变为反向，但这样会改变原本的链表结构。所以，通常情况下我们不希望改变原本的链表结构。换个角度思考，反向输出链表，那就是经典的“先进后出”数据结构，即借助栈（stack）这种数据结构完成链表的反转。总体的算法步骤如下：</p>
<span id="more"></span>
<ul>
<li>遍历链表的节点，每经过一个节点，就将该节点放到一个栈当中；</li>
<li>遍历完整个链表过后，再从栈顶开始逐个输出节点的值赋值给新的链表；</li>
</ul>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p><strong>c++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        stack&lt;int&gt; nodes;//栈</span><br><span class="line">        vector&lt;int&gt; result;//新链表</span><br><span class="line">        ListNode* node=head;//原链表</span><br><span class="line">        while(node != NULL)&#123;//遍历原链表，将遍历结果给栈结构nodes</span><br><span class="line">            nodes.push(node-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!nodes.empty())&#123;//当栈非空时，从栈顶依次将节点输出给新链表result</span><br><span class="line">            result.push_back(nodes.top());</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python2.7:</strong><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于python来讲，可以直接使用列表的插入方法，每次插入数据，只插入在首位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"> </span><br><span class="line">class Solution:</span><br><span class="line">    # 返回从尾部到头部的列表值序列，例如[1,2,3]</span><br><span class="line">    def printListFromTailToHead(self, listNode):</span><br><span class="line">        # write code here</span><br><span class="line">        result = []</span><br><span class="line">        while listNode:</span><br><span class="line">            result.insert(0, listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>EP09-剑指offer——4.重建二叉树</title>
    <url>/2019/08/04/EP09-jianzhioffer04/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>树是一种经典的数据结构，通常有以下三种遍历方式：</p>
<ul>
<li>1.前序遍历：a.先访问根节点，b.再访问左子节点，c.最后访问右子节点。</li>
<li>2.中序遍历：a.先访问左子节点，b.再访问根节点，c.最后访问右子节点。</li>
<li>3.后序遍历：a.先访问左子节点，b.再访问右子节点，c.最后访问根节点。<br>一般二叉树的重建最少需要两种遍历方式，前序遍历和中序遍历，或者前序遍历和后序遍历。本题目中给出的条件是前序遍历和中序遍历结果，总体的算法步骤如下：<span id="more"></span></li>
<li>前序遍历中，第一个数字总是树的根节点的值；</li>
<li>根据第1步的结果，可以在中序遍历序列中确定，左子树的节点值位于根节点值的左边，右子树节点的值位于根节点值的右边；</li>
<li>剩余数字根据第1、2步递归实现。<img src="/2019/08/04/EP09-jianzhioffer04/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BE%8B%E5%AD%90.jpg" class="" title="二叉树例子"></li>
</ul>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p><strong>c++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Definition for binary tree</span><br><span class="line">    * struct TreeNode &#123;</span><br><span class="line">    *     int val;</span><br><span class="line">    *     TreeNode *left;</span><br><span class="line">    *     TreeNode *right;</span><br><span class="line">    *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">    * &#125;;</span><br><span class="line">    */</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">           if (pre.size() == 0)&#123;//若子树为空，则返回NULL</span><br><span class="line">               return NULL;</span><br><span class="line">           &#125;</span><br><span class="line">           //分别是前序左子树，前序又子树，中序左子树，中序右子树</span><br><span class="line">           vector&lt;int&gt; left_pre,right_pre,left_vin,right_vin;</span><br><span class="line">           //前序遍历的第一个数字必定为树的根节点</span><br><span class="line">           TreeNode* head = new TreeNode(pre[0]);</span><br><span class="line">           int root = 0;</span><br><span class="line">           for(int i = 0;i &lt; pre.size();i++)//找到根节点在中序遍历中的位置，在该位置前的为左子树，在该位置之后的为右子树</span><br><span class="line">           &#123;</span><br><span class="line">               if(pre[0] == vin[i])&#123;</span><br><span class="line">                   root = i;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           for(int i = 0;i &lt; root;i++)&#123;//中序遍历中的根节点，对二叉树中的节点进行归并</span><br><span class="line">               left_vin.push_back(vin[i]);</span><br><span class="line">               left_pre.push_back(pre[i+1]);//前序遍历第一个数为根节点</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           for(int i = root+1;i &lt; pre.size();i++)&#123;</span><br><span class="line">               right_vin.push_back(vin[i]);</span><br><span class="line">               right_pre.push_back(pre[i]);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           //递归，对左、右子树进行下一步区分，直到找到树的叶节点</span><br><span class="line">           head-&gt;left = reConstructBinaryTree(left_pre,left_vin);</span><br><span class="line">           head-&gt;right = reConstructBinaryTree(right_pre,right_vin);</span><br><span class="line">           return head;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python2.7:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回构造的TreeNode根节点</span><br><span class="line">    def reConstructBinaryTree(self, pre, tin):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(pre) == 0:</span><br><span class="line">            return None</span><br><span class="line">        elif len(pre) == 1:</span><br><span class="line">            return TreeNode(pre[0])</span><br><span class="line">        else:</span><br><span class="line">            root = TreeNode(pre[0])</span><br><span class="line">            pos = tin.index(pre[0])</span><br><span class="line">            root.left = self.reConstructBinaryTree(pre[1:pos+1], tin[:pos])</span><br><span class="line">            root.right = self.reConstructBinaryTree(pre[pos+1:], tin[pos+1:])</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>EP10-剑指offer——5.用两个栈实现队列</title>
    <url>/2019/08/04/EP10-jianzhioffer05/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
</blockquote>
<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>栈的特点是“先进后出”，即最先被压入（push）的元素会被最后一个弹出（pop）。<br>队列的特点是“先进先出”，即最先进入队列的元素会第一个出来。<br>两个数据结构的特点正好完全相反，那可以想到“负负得正”，创建两个栈，将第一个栈stack1中的元素放到第二个栈stack2中，使用两个“先进后出”栈实现一个先进先出的队列。总体的思路如下：</p>
<span id="more"></span>
<ul>
<li>当stack2中不为空，在stack2的栈顶元素是最先进入队列的元素，此时可以弹出。</li>
<li>当stack2中为空时，再把stack1中的元素逐个弹出并压入stack2。</li>
<li>此时先进入队列的元素被压入stack1的栈底，经过弹出和压入操作之后就处于stack2的栈顶，可以直接弹出。若再有新的队列元素，直接将其压入stack1即可。</li>
</ul>
<h3 id="3-举例说明"><a href="#3-举例说明" class="headerlink" title="3.举例说明"></a>3.举例说明</h3><p>通过一个具体的例子分析往该队列插入和删除元素的过程。首先插入一个元素a，先把它插入stack1，此时stack1中的元素有{a}，stack2为空。再压入两个元素b和c，还是插入到stack1中，此时stack1的元素有{a,b,c}，其中c位于栈顶，而stack2仍然是空的。</p>
<p>这时试着从队列中删除一个元素:</p>
<ul>
<li>按照先入先出的规则，由于a比b、c先插入队列中，最先删除的元素应该是a。元素a存储在stack1中，但并不在栈顶，因此不能直接进行删除操作。</li>
<li>如果把stack1中的元素逐个弹出压入stack2，元素在stack2中的顺序正好和原来在stack1中的顺序相反。</li>
<li>因此经过3次弹出stack1和要入stack2操作之后，stack1为空，而stack2中的元素是{c,b,a}，这个时候就可以弹出stack2的栈顶a了。此时的stack1为空，而stack2的元素为{b,a}，其中b在栈顶。<img src="/2019/08/04/EP10-jianzhioffer05/%E4%BE%8B%E5%AD%90.jpg" class="" title="例子"></li>
</ul>
<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p><strong>c++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">   &#123;</span><br><span class="line">   public:</span><br><span class="line">       void push(int node) &#123;</span><br><span class="line">           stack1.push(node);//新元素加入stack1中</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       int pop() &#123;</span><br><span class="line">           if(stack2.empty())&#123;//当stack2中的元素为空时，将stack1中的栈顶元素逐个弹出并压入stack2</span><br><span class="line">               while(stack1.size()&gt;0)&#123;</span><br><span class="line">                   int data = stack1.top();</span><br><span class="line">                   stack1.pop();</span><br><span class="line">                   stack2.push(data);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           int pop_elem = stack2.top();//弹出元素为stack2的栈顶元素</span><br><span class="line">           stack2.pop();</span><br><span class="line">           return pop_elem;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">   private:</span><br><span class="line">       stack&lt;int&gt; stack1;</span><br><span class="line">       stack&lt;int&gt; stack2;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python2.7:</strong><br>对于python来讲，栈就是用list实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">       def __init__(self):</span><br><span class="line">           self.stack1 = []</span><br><span class="line">           self.stack2 = []</span><br><span class="line">       def push(self, node):</span><br><span class="line">           # write code here</span><br><span class="line">           self.stack1.append(node)</span><br><span class="line">       def pop(self):</span><br><span class="line">           # return xx</span><br><span class="line">           if len(self.stack2) == 0:</span><br><span class="line">               while self.stack1:</span><br><span class="line">                   self.stack2.append(self.stack1.pop())</span><br><span class="line">           return self.stack2.pop()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>EP11-剑指offer——6.旋转数组的最小数字</title>
    <url>/2019/08/04/EP11-jianzhioffer06/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 (NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。)</p>
</blockquote>
<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们可以注意到旋转之后的数组其实可以划分为两个排序的子数组，并且该数组的特点是前面的子数组中的元素总是大于或者等于后面子数组的元素。其中最小的元素正好是这两个数组的分界线。本题给出的数组在一定范围内是排序的，因此我们可以用二分查找法来实现O（logn）的查找。具体的算法步骤如下：</p>
<span id="more"></span>
<ul>
<li>以数组{3,4,5,1,2}为例，我们可以找到数组的中间元素，定义两个指针P1和P2，左指针P1指向数组的第一个元素，右指针P2指向最后一个元素。如果中间元素位于前面的递增子数组，那么它应该大于或者等于P1所指向的元素。此时最小元素应该位于该中间元素之后，然后把P1指向该中间元素，移动之后P1仍然处于前面的递增子数组中。</li>
<li>同样，若中间元素位于后面的递增子数组，那么其应该小于P2所指向的元素。此时最小元素应该在该中间元素之前，然后我们把P2指向该中间元素。移动之后P2仍然位于后面的递增子数组中。</li>
<li>P1总是指向前面递增子数组的元素，P2总是指向后面递增子数组的元素，最终P1和P2会指向两个相邻的元素，这就是循环结束的条件。<img src="/2019/08/04/EP11-jianzhioffer06/%E6%95%B0%E7%BB%84%E8%BE%93%E5%87%BA%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.jpg" class="" title="数组输出最小数字"></li>
</ul>
<h3 id="3-特殊案例"><a href="#3-特殊案例" class="headerlink" title="3.特殊案例"></a>3.特殊案例</h3><ul>
<li>如果把排序数组的0个元素搬到最后面，这仍然是旋转数组，我们的代码需要支持这种情况。如果发现数组中的第一个数字小于最后一个数字，表明该数组是排序的，就可以直接返回第一个数字了。</li>
<li>下面这种情况，即第一个指针指向的数字、第二个指针指向的数字和中间的数字三者相等，我们无法判断中间的数字1属于前面的递增子数组还是后面的递增子数组。这样的话，我们只能进行顺序查找。<img src="/2019/08/04/EP11-jianzhioffer06/%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.jpg" class="" title="数组顺序查找"></li>
</ul>
<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><p><strong>C++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        int size = rotateArray.size();                            //数组长度</span><br><span class="line">        if(size == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 0;                                            //左指针P1</span><br><span class="line">        int right = size - 1;                                    //右指针P2</span><br><span class="line">        int mid = 0;                                            //中间指针</span><br><span class="line">        while(rotateArray[left] &gt;= rotateArray[right])&#123;            //确保旋转</span><br><span class="line">            if(right - left == 1)&#123;                                //左右指针相邻</span><br><span class="line">                mid = right;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = left + (right - left) / 2;                    //计算中间指针位置</span><br><span class="line">            //特殊情况：如果无法确定中间元素是属于前面还是后面的递增子数组，只能顺序查找</span><br><span class="line">            if(rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[mid] == rotateArray[left])&#123;</span><br><span class="line">                return MinInOrder(rotateArray, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">            //中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面</span><br><span class="line">            if(rotateArray[mid] &gt;= rotateArray[left])&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            //中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面</span><br><span class="line">            else&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //顺序寻找最小值</span><br><span class="line">    int MinInOrder(vector&lt;int&gt; &amp;num, int left, int right)&#123;</span><br><span class="line">        int result = num[left];</span><br><span class="line">        for(int i = left + 1; i &lt; right; i++)&#123;</span><br><span class="line">            if(num[i] &lt; result)&#123;</span><br><span class="line">                result = num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python2.7：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">       def minNumberInRotateArray(self, rotateArray):</span><br><span class="line">           # write code here</span><br><span class="line">           if len(rotateArray) == 0:</span><br><span class="line">               return 0</span><br><span class="line">           left = 0</span><br><span class="line">           right = len(rotateArray) - 1</span><br><span class="line">           mid = 0</span><br><span class="line">           while rotateArray[left] &gt;= rotateArray[right]:</span><br><span class="line">               if right - left == 1:</span><br><span class="line">                   mid = right</span><br><span class="line">                   break</span><br><span class="line">               mid = left + (right - left) // 2</span><br><span class="line">               if rotateArray[left] == rotateArray[mid] and rotateArray[mid] == rotateArray[right]:</span><br><span class="line">                   return self.minInorder(rotateArray, left, right)</span><br><span class="line">               if rotateArray[mid] &gt;= rotateArray[left]:</span><br><span class="line">                   left = mid</span><br><span class="line">               else:</span><br><span class="line">                   right = mid</span><br><span class="line">           return rotateArray[mid]</span><br><span class="line">       </span><br><span class="line">       def minInorder(self, array, left, right):</span><br><span class="line">           result = array[left]</span><br><span class="line">           for i in range(left+1, right+1):</span><br><span class="line">               if array[i] &lt; result:</span><br><span class="line">                   result = array[i]</span><br><span class="line">           return result</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>EP12-剑指offer——7.裴波那契数列</title>
    <url>/2019/08/10/EP12-jianzhioffer07/</url>
    <content><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><blockquote>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;&#x3D;39）<br>  斐波那契数列公式为：</p>
</blockquote>
<img src="/2019/08/10/EP12-jianzhioffer07/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%85%AC%E5%BC%8F.jpg" class="" title="斐波那契数列公式">

<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>我们可以以求解f（10）为例来分析递归的求解过程。想要求得f（10），我们要先知道f（9）和f（8）。同样的，要求得f（9），需要先知道f（8）和f（7）。。。我们可以使用树形结构来表示这种依赖关系，如下图所示。</p>
<span id="more"></span>
<img src="/2019/08/10/EP12-jianzhioffer07/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.jpg" class="" title="斐波那契树形结构">

<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不难发现在这棵树中有许多的节点都是重复的，而且重复的节点数会随着n的增大而急剧增加，这意味着计算量会随着n的增大而急剧增大。事实上用递归方法计算的时间复杂度是以n的指数方式递增的。改进上述方法并不难，只要想办法避免重复计算就可以了，比如可以将已经得到的数列中间项保存起来，如果下次需要计算的话先查找一下，已经计算过的就不用重复再计算了。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;更简单的办法是从下往上计算，即使用简单的循环方法来实现。</p>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p><strong>C++：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       int Fibonacci(int n) &#123;</span><br><span class="line">           if(n &lt;= 0)&#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if(n ==1 )&#123;</span><br><span class="line">               return 1;</span><br><span class="line">           &#125;</span><br><span class="line">           int first = 0,second = 1,third = 0;</span><br><span class="line">           for(int i = 2;i &lt;= n;i++)&#123;</span><br><span class="line">               third = first + second;</span><br><span class="line">               first = second;</span><br><span class="line">               second = third;</span><br><span class="line">           &#125;</span><br><span class="line">           return third;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python2.7：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">       def Fibonacci(self, n):</span><br><span class="line">           # write code here</span><br><span class="line">           if n &lt;= 1:</span><br><span class="line">               return n</span><br><span class="line">           first, second, third = 0, 1, 0</span><br><span class="line">           for i in range(2, n+1):</span><br><span class="line">               third = first + second</span><br><span class="line">               first = second</span><br><span class="line">               second = third</span><br><span class="line">           return third</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>EP13-后端管理系统部署操作手册(Linux CentOS7.5)</title>
    <url>/2023/02/28/EP13-website-build-notes/</url>
    <content><![CDATA[<p>兄弟分行做了一个客户信息管理系统，架构是后台管理系统+小程序的配置。后台管理系统即一个网站的部署，小程序使用了低码平台开发，可以远程推送在手机上测试。本文档主要用于网站部署过程的记录。</p>
<span id="more"></span>

<h2 id="一、服务器基础配置"><a href="#一、服务器基础配置" class="headerlink" title="一、服务器基础配置"></a>一、服务器基础配置</h2><h3 id="1-Java11安装"><a href="#1-Java11安装" class="headerlink" title="1. Java11安装"></a>1. Java11安装</h3><ol>
<li><p>下载安装包：<a href="https://www.oracle.com/java/technologies/downloads/#java11">https://www.oracle.com/java/technologies/downloads/#java11</a></p>
<p>安装包名称：jdk-11.0.18_linux-x64_bin.tar.gz</p>
</li>
<li><p>上传JDK至云服务器：&#x2F;usr&#x2F;local</p>
</li>
<li><p>解压JDK：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建目录</span><br><span class="line">mkdir /usr/local/java</span><br><span class="line"></span><br><span class="line"># 解压文件到指定目录（查看是否有lib、bin文件夹）</span><br><span class="line">tar -zxvf ./jdk-11.0.18_linux-x64_bin.tar.gz -C /usr/local/java</span><br><span class="line"></span><br><span class="line">#删除安装包</span><br><span class="line">rm -f jdk-11.0.18_linux-x64_bin.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置java的环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打开配置文件</span><br><span class="line">vi /etc/profile</span><br><span class="line"> </span><br><span class="line">#点击i进入编辑模式，在文件末尾添加</span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk-11.0.18</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib/</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line">#按Esc键退出编辑，最后输入 :wq 保存编辑，并回车退出（注意有“:”）</span><br><span class="line"></span><br><span class="line"># 刷新环境变量</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证java是否安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">成功示例：</span><br><span class="line">java version &quot;11.0.18&quot; 2023-01-17 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.18+9-LTS-195)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.18+9-LTS-195, mixed mode)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建软链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建软链接</span><br><span class="line">ln -s /usr/local/java/jdk-11.0.18/bin/java /usr/bin</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://cloud.tencent.com/developer/article/2080307">https://cloud.tencent.com/developer/article/2080307</a></p>
<p>参考链接：<a href="https://blog.csdn.net/dubhe_zhao/article/details/125387612">https://blog.csdn.net/dubhe_zhao/article/details/125387612</a></p>
</li>
</ol>
<h3 id="2-mysql-安装"><a href="#2-mysql-安装" class="headerlink" title="2.mysql 安装"></a>2.mysql 安装</h3><ol>
<li><p>从官网下载用于Linux的Mysql安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://cdn.mysql.com/archives/mysql-8.0/mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xvf mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz </span><br></pre></td></tr></table></figure>
</li>
<li><p>移动解压后的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv mysql-8.0.19-linux-glibc2.12-x86_64 /usr/local/mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>在&#x2F;usr&#x2F;local&#x2F;mysql目录下新建data文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/mysql/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改mysql配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入配置文件</span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line">#以下为添加内容：</span><br><span class="line">[mysqld]</span><br><span class="line">datadir=/usr/local/mysql/data</span><br><span class="line">port=3306</span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">symbolic-links=0</span><br><span class="line">max_connections=600</span><br><span class="line">innodb_file_per_table=1</span><br><span class="line">log-error=/usr/local/mysql/data/error.log</span><br><span class="line">lower_case_table_names=1</span><br><span class="line"># skip-grant-tables</span><br><span class="line">#</span><br><span class="line"># include all files from the config directory</span><br><span class="line"></span><br><span class="line">#esc键退出，输入 :wq 并回车</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改mysql目录下所有的目录及文件夹所属的用户组和用户，以及权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R mysql:mysql /usr/local/mysql</span><br><span class="line">chmod -R 755 /usr/local/mysql</span><br></pre></td></tr></table></figure>

<p>如报错：chown: invalid user: ‘mysql:mysql’</p>
<p>执行以下语句之后，再重新授权：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方法一：</span><br><span class="line">chattr -ia /etc/passwd</span><br><span class="line">chattr -ia /etc/group</span><br><span class="line">chattr -ia /etc/shadow</span><br><span class="line">chattr -ia /etc/gshadow</span><br><span class="line">yum install mysql-server</span><br><span class="line"></span><br><span class="line">#方法二：</span><br><span class="line">useradd -d /var/lib/mysql mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装并初始化mysql,务必记住初始化输出日志末尾的密码（数据库管理员临时密码）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql/bin</span><br><span class="line">./mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试启动mysql服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/mysql/support-files/mysql.server start</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加软连接，并重启mysql服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql</span><br><span class="line">ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果root用户的密码遗失，需重置。因后端密码写死，密码需设置为固定密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入配置文件</span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line">#设置mysql免密</span><br><span class="line">skip-grant-tables</span><br><span class="line"></span><br><span class="line">#退出编辑，重启mysql</span><br><span class="line">service mysql restart</span><br><span class="line"></span><br><span class="line">#进入mysql数据库：</span><br><span class="line">[root@VM-4-2-centos bin]# mysql</span><br><span class="line"></span><br><span class="line">#切换为mysql</span><br><span class="line">mysql&gt;use mysql;</span><br><span class="line"></span><br><span class="line">#如果更新密码时报错：ERROR 1396 (HY000): Operation ALTER USER failed for &#x27;root&#x27;@&#x27;%&#x27;</span><br><span class="line">mysql&gt; update user set host = &#x27;%&#x27; where host = &#x27;localhost&#x27; and user = &#x27;root&#x27;;</span><br><span class="line"></span><br><span class="line">#刷新权限：</span><br><span class="line">mysql&gt;flush privileges;</span><br><span class="line"></span><br><span class="line">#设置root用户新密码：</span><br><span class="line">mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;new_passowrd&#x27;;</span><br><span class="line"></span><br><span class="line">#刷新权限：</span><br><span class="line">mysql&gt;flush privileges;</span><br><span class="line"></span><br><span class="line">#退出mysql</span><br><span class="line">mysql&gt;exit;</span><br><span class="line"></span><br><span class="line">#进入配置文件</span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line">#设置mysql需要密码：</span><br><span class="line"># skip-grant-tables</span><br><span class="line"></span><br><span class="line">#退出编辑，重启mysql</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>

<p>整体流程参考：<a href="https://blog.csdn.net/Box_clf/article/details/124599166">https://blog.csdn.net/Box_clf/article/details/124599166</a></p>
<p>设置密码报错参考：<a href="https://www.cnblogs.com/223zhp/p/16208226.html">https://www.cnblogs.com/223zhp/p/16208226.html</a></p>
</li>
<li><p>开启服务器的3306防火墙规则；</p>
</li>
<li><p>开启mysql8.0的远程连接功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入数据库中</span><br><span class="line">mysql -u root -p &#x27;new_passowrd&#x27;</span><br><span class="line"></span><br><span class="line">#切换数据库</span><br><span class="line">use mysql;</span><br><span class="line"></span><br><span class="line">#开启root用户远程访问权限：</span><br><span class="line">GRANT ALL ON *.* TO &#x27;root&#x27;@&#x27;%&#x27;;</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;你的密码&#x27;;</span><br><span class="line"></span><br><span class="line">#刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line">#退出mysql</span><br><span class="line">exit;</span><br><span class="line"></span><br><span class="line">#重启mysql</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用navicat远程连接mysql数据库，新建数据库sxh:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置：字符集 utf8mb4，排序规则 utf8mb4_0900_ai_ci；</span><br></pre></td></tr></table></figure>
</li>
<li><p>迁移表结构及数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.右击连接名：shfruit；</span><br><span class="line">2.选择“运行SQL文件”；</span><br><span class="line">3.文件选择目标文件，编码默认UTF-8；</span><br><span class="line">4.点击“开始”；</span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考链接：<a href="https://cloud.tencent.com/developer/article/2081683">https://cloud.tencent.com/developer/article/2081683</a></p>
<p>参考链接：<a href="https://www.cnblogs.com/nnnyg/p/15609532.html">https://www.cnblogs.com/nnnyg/p/15609532.html</a></p>
<p>参考链接：<a href="https://blog.csdn.net/z15711187787/article/details/124986309">https://blog.csdn.net/z15711187787/article/details/124986309</a></p>
<h3 id="3-Nginx-安装"><a href="#3-Nginx-安装" class="headerlink" title="3.Nginx 安装"></a>3.Nginx 安装</h3><ol>
<li><p>下载源码包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.19.3.tar.gz -P /usr/local</span><br><span class="line">cd /usr/local</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装nginx依赖包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc pcre-devel zlib-devel</span><br><span class="line">  - gcc: 源码编译工具 </span><br><span class="line">  - pcre-devel： nginx url_rewrite 功能提供包 </span><br><span class="line">  - zlib-devel： nginx 压缩功能提供包	</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压nginx源码，并进入源码包:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xf nginx-1.19.3.tar.gz</span><br><span class="line">cd nginx-1.19.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置nginx源码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</span><br><span class="line">    配置目的：</span><br><span class="line">      1）检查环境 是否 满足安装条件     依赖解决</span><br><span class="line">      2）指定安装方式    配置文件   命令文件  各种文件放哪里   开启模块功能【内置模块  三方模块】</span><br><span class="line">      3）指定软件安装在那里</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装nginx:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>nginx的启动及测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置文件测试</span><br><span class="line">/usr/local/nginx/sbin/nginx -t</span><br><span class="line">#启动</span><br><span class="line">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">#停止</span><br><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">#重载</span><br><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">#杀掉nginx</span><br><span class="line">/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line">使用浏览器访问nginx默认网站</span><br><span class="line"> [root@zutuanxue ~]# http://服务器对应IP</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>nginx的启动及测试：</p>
<p>参考链接：<a href="https://cloud.tencent.com/developer/article/2108431">https://cloud.tencent.com/developer/article/2108431</a></p>
</li>
</ol>
<h2 id="二、系统前后端部署"><a href="#二、系统前后端部署" class="headerlink" title="二、系统前后端部署"></a>二、系统前后端部署</h2><h3 id="1-后端部署"><a href="#1-后端部署" class="headerlink" title="1.后端部署"></a>1.后端部署</h3><ol>
<li><p>新建 &#x2F;usr&#x2F;local&#x2F;jar 文件夹；</p>
</li>
<li><p>将投产的jar包复制到该目录下；</p>
</li>
<li><p>将自动运行脚本 start.sh 文件复制到该目录下；</p>
</li>
<li><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/jar </span><br><span class="line">./start.sh</span><br><span class="line"></span><br><span class="line">#若无权限则执行 chmod u+x start.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-前端部署"><a href="#2-前端部署" class="headerlink" title="2.前端部署"></a>2.前端部署</h3><ol>
<li>根目录下新建&#x2F;web&#x2F;mercury-sxh-service-web-prod&#x2F;文件夹</li>
<li>前端打包dist文件部署至&#x2F;web&#x2F;mercury-sxh-service-web-prod&#x2F;</li>
<li>低代码小程序的前端文件部署至&#x2F;web&#x2F;static&#x2F;files</li>
</ol>
<h3 id="3-nginx配置"><a href="#3-nginx配置" class="headerlink" title="3.nginx配置"></a>3.nginx配置</h3><p>按照示例文件进行配置，主要是域名及默认跳转路径的调整。</p>
<p><a href="https://blog.csdn.net/lin5188230/article/details/124009508">https://blog.csdn.net/lin5188230/article/details/124009508</a></p>
<p><a href="https://blog.csdn.net/weixin_41709748/article/details/127604499">https://blog.csdn.net/weixin_41709748/article/details/127604499</a></p>
<h3 id="三、疑难杂症报错记录"><a href="#三、疑难杂症报错记录" class="headerlink" title="三、疑难杂症报错记录"></a>三、疑难杂症报错记录</h3><p>1.装了四五台服务器，突然遇到这个错误，真滴绝，找半天不知道咋解决，记录一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#报错日志：</span><br><span class="line">Caused by: java.lang.reflect.InvocationTargetException: null</span><br><span class="line">	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)</span><br><span class="line">	at java.desktop/sun.font.FontManagerFactory$1.run(FontManagerFactory.java:84)</span><br><span class="line">	... 139 common frames omitted</span><br><span class="line">Caused by: java.lang.NullPointerException: null</span><br><span class="line">	at java.desktop/sun.awt.FontConfiguration.getVersion(FontConfiguration.java:1262)</span><br><span class="line">	at java.desktop/sun.awt.FontConfiguration.readFontConfigFile(FontConfiguration.java:225)</span><br><span class="line">	at java.desktop/sun.awt.FontConfiguration.init(FontConfiguration.java:107)</span><br><span class="line">	at java.desktop/sun.awt.X11FontManager.createFontConfiguration(X11FontManager.java:719)</span><br><span class="line">	at java.desktop/sun.font.SunFontManager$2.run(SunFontManager.java:379)</span><br><span class="line">	at java.base/java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">	at java.desktop/sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:324)</span><br><span class="line">	at java.desktop/sun.awt.FcFontManager.&lt;init&gt;(FcFontManager.java:35)</span><br><span class="line">	at java.desktop/sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:56)</span><br><span class="line">	... 144 common frames omitted</span><br><span class="line">	</span><br><span class="line">#解决方案：</span><br><span class="line">yum -y install fontconfig</span><br><span class="line">fc-cache</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>服务器部署</tag>
      </tags>
  </entry>
  <entry>
    <title>EP14-网页管理系统&amp;小程序部署记录【开发&gt;&gt;&gt;生产】</title>
    <url>/2023/07/10/EP14-management-system-and-mini-program/</url>
    <content><![CDATA[<p>整个六月都扑在一个政策搜索小程序项目上，项目包括网页管理系统和小程序两部分，网页管理系统用于上传现有政策，小程序端纯做展示和搜索功能。</p>
<p>网页管理系统包括前后端，使用行内脚手架开发，小程序使用百度低代码平台完成页面开发及接口交互。</p>
<span id="more"></span>

<h2 id="一、网页管理系统"><a href="#一、网页管理系统" class="headerlink" title="一、网页管理系统"></a>一、网页管理系统</h2><hr>
<h3 id="1-后端"><a href="#1-后端" class="headerlink" title="1.后端"></a>1.后端</h3><ol>
<li><p>安装maven至本地，本次下载的是maven3.9.3；</p>
</li>
<li><p>使用IDEA打开后端项目代码，在设置中将maven的home path、settings file、repository设置为本地文件和路径；</p>
</li>
<li><p>在项目maven的lifecycle中双击install，将自动下载项目所依赖的包到本地repository；</p>
</li>
<li><p>运行项目，查看报错模块，注释掉不起作用的函数；</p>
</li>
<li><p>点击maven的lifecycle中的package即可打包，路径为target文件夹下的jar包；</p>
</li>
<li><p>运行命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.找到jar所在</span><br><span class="line">cd /home/cloud/qp</span><br><span class="line"></span><br><span class="line">1.查找目标进程值</span><br><span class="line">ps -ef|grep java</span><br><span class="line"></span><br><span class="line">2.杀掉java进程</span><br><span class="line">kill -9 目标进程值</span><br><span class="line"></span><br><span class="line">3.启动项目</span><br><span class="line">    方法一：</span><br><span class="line">    nohup java -jar XXXXXX-service-1.0.0.jar —server.port=9099 &gt;nohup.out 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">    方法二：（调用application.yml文件中默认的启动方式）</span><br><span class="line">    java -jar xxxxxx.jar  --server.port = &lt;端口号&gt;</span><br><span class="line"></span><br><span class="line">    方法三：</span><br><span class="line">    1）复制go.sh文件到项目文件夹下</span><br><span class="line">    2）启动语句：sh ./go.sh XXXXXXX-service prod &lt;端口号&gt;</span><br><span class="line"></span><br><span class="line">4.查看日志</span><br><span class="line">tail -1000f nohup.out</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-前端"><a href="#2-前端" class="headerlink" title="2.前端"></a>2.前端</h3><ol>
<li>使用VScode打开前端项目代码，使用node -v查看node版本，确保和开发环境使用的node大版本一致，因为每个版本拉取的依赖包不一致，会使项目存在版本差，导致项目报错；</li>
<li>可使用npm -v再查看下npm的版本，理论上两者版本一致；</li>
<li>使用npm install下载项目所依赖的外部包，会下载到项目的node_modules文件夹中；</li>
<li>使用npm run local本地化运行项目，成功打开即可；</li>
<li>打包使用npm run build:prod命令，路径为dist文件夹下的所有文件；</li>
</ol>
<h2 id="二、小程序"><a href="#二、小程序" class="headerlink" title="二、小程序"></a>二、小程序</h2><hr>
<ol>
<li>使用百度低代码平台画页面，导入API并测试，可在开发环境联动本地数据进行调试；</li>
<li>待第一步完成，页面、功能、数据测试完毕后，同样的项目导出，重命名为发布版本进行调试，实际上本地开发环境和外网生产环境存在太多不一致；</li>
<li>灵活使用postman测试后端接口，很多时候数据无法返回就是后端接口有问题需要改造；</li>
<li>报错及时查看后端代码，调整相应的返回接口；</li>
</ol>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>网页管理系统</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>EP15-如何杀死目标端口号进程</title>
    <url>/2024/02/04/EP15-kill-pc-port-task/</url>
    <content><![CDATA[<h3 id="一、查找占用端口号的进程"><a href="#一、查找占用端口号的进程" class="headerlink" title="一、查找占用端口号的进程"></a>一、查找占用端口号的进程</h3><p>在对端口号进行操作之前，需要先找到占用该端口号的进程，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr :端口号</span><br></pre></td></tr></table></figure>

<p>其中，“端口号”是需要杀死进程的端口号。</p>
<p>执行该命令后，将会显示所有占用该端口号的进程，其中最后一列是该进程的PID（进程ID）。</p>
<span id="more"></span>

<h2 id="二、通过PID杀死进程"><a href="#二、通过PID杀死进程" class="headerlink" title="二、通过PID杀死进程"></a>二、通过PID杀死进程</h2><p>获取到PID后，可以使用以下命令杀死对应的进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskkill /pid 进程PID /f</span><br></pre></td></tr></table></figure>

<p>其中，“进程PID”是需要杀死的进程的PID。参数&#x2F;f表示强制终止该进程。</p>
<p>执行该命令后，该进程将会被强制终止。</p>
<h2 id="三、通过端口号杀死进程"><a href="#三、通过端口号杀死进程" class="headerlink" title="三、通过端口号杀死进程"></a>三、通过端口号杀死进程</h2><p>如果不想先通过netstat命令获取到进程的PID，也可以直接使用以下命令杀死对应端口号的进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskkill /f /pid $(netstat -ano | findstr :端口号 | awk &#x27;&#123;print $5&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p>其中，“端口号”是需要杀死进程的端口号。该命令将会自动查找到对应的PID并杀死进程。</p>
<h2 id="四、通过进程名杀死进程"><a href="#四、通过进程名杀死进程" class="headerlink" title="四、通过进程名杀死进程"></a>四、通过进程名杀死进程</h2><p>如果已知需要杀死的进程名，也可以使用以下命令杀死该进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskkill /f /im 进程名</span><br></pre></td></tr></table></figure>

<p>其中，“进程名”是需要杀死的进程名。参数&#x2F;f表示强制终止该进程。</p>
<p>执行该命令后，该进程将会被强制终止。</p>
<h2 id="五、通过批处理批量杀死进程"><a href="#五、通过批处理批量杀死进程" class="headerlink" title="五、通过批处理批量杀死进程"></a>五、通过批处理批量杀死进程</h2><p>如果需要批量杀死多个进程，可以使用批处理脚本来实现。以下是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">set port=8080</span><br><span class="line">set count=0</span><br><span class="line"></span><br><span class="line">for /f &quot;tokens=5 delims= &quot; %%a in (&#x27;netstat -ano ^| findstr :%port%&#x27;) do (</span><br><span class="line">    set /a count+=1</span><br><span class="line">    set pid[!count!]=%%a</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">for /l %%i in (1, 1, %count%) do (</span><br><span class="line">    echo Killing process with pid !pid[%%i]!</span><br><span class="line">    taskkill /f /pid !pid[%%i]!</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>该脚本通过查找端口号为8080的进程，并将对应的PID保存在数组中。然后依次遍历数组，杀死对应的进程。</p>
<h2 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h2><p>在杀死进程时，请注意以下事项：</p>
<ul>
<li>请确保只杀死不需要的进程，不要随意杀死系统内部的重要进程。</li>
<li>杀死进程将会导致正在进行的任务被强制终止，请确保没有重要数据或任务正在进行。</li>
<li>请谨慎使用批处理脚本等批量操作方式，以免误伤有用进程。</li>
</ul>
<p>参考链接：<a href="https://www.python100.com/html/Q04KL23XP62J.html">https://www.python100.com/html/Q04KL23XP62J.html</a></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>服务器部署</tag>
        <tag>开发技能</tag>
      </tags>
  </entry>
  <entry>
    <title>EP16-系统研发脚手架初始化SOP</title>
    <url>/2024/07/11/EP16-environment-init-notes/</url>
    <content><![CDATA[<p>拉取前后端脚手架之后的一些开发初始化操作及常见问题记录。</p>
<span id="more"></span>

<h2 id="一、后端"><a href="#一、后端" class="headerlink" title="一、后端"></a>一、后端</h2><ol>
<li><p>脚手架生成中心填写信息，生成脚手架；</p>
</li>
<li><p>在数据库服务器上新建项目所属数据库；</p>
</li>
<li><p>更改application-local中的jdbc连接信息；（数据库服务器地址、用户名、用户密码、数据库名）</p>
</li>
<li><p>使用scripts&#x2F;sql中的MySQL建表语句在navicat中导入初始系统表；</p>
</li>
<li><p>打开File—Settings—Compiler—“Shared build process heap VM options”设置为以下值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Djps.track.ap.dependencies=false</span><br></pre></td></tr></table></figure>
</li>
<li><p>右上角添加“test“的application运行配置：Add New Configuration—Application—设置name—Build and run选择Application（com.XXXXX项目名称）</p>
</li>
<li><p>在项目数据库下根据前期表结构设计文档，新建业务表</p>
</li>
<li><p>使用postman跳过token校验，修改application-local中的shiro-auth后面的路径，即可跳过校验；</p>
</li>
<li><p>拆分业务代码架构需要在代码原始配置中增加扫描路径，autoconfiguration中添加相关代码路径；</p>
</li>
</ol>
<h2 id="二、前端"><a href="#二、前端" class="headerlink" title="二、前端"></a>二、前端</h2><ol>
<li><p>脚手架生成中心填写信息，生成脚手架；</p>
</li>
<li><p>package-lock.json是自动生成的文件，重新下载需要和node_modules文件夹一起删除，重新下载，建议使用yarn install命令安装；</p>
</li>
<li><p>npmrc文件需要把最后一行的注释解除，改为自己项目的路径；</p>
</li>
<li><p>在terminal终端窗口使用以下命令下载项目所需包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="三、问题记录"><a href="#三、问题记录" class="headerlink" title="三、问题记录"></a>三、问题记录</h2><p>1、implement methods：实现基类或接口中的方法；</p>
<p>2、@RestController注解：类中的方法返回的数据可以直接作为HTTP响应的内容，而不需要通过视图解析器进行渲染。</p>
<p>3、@ComponentScan注解：将组件自动加载到容器，加了包扫描@ComponentScan注解后，只要标注了@Controller、@Service、@Repository、@Component注解中的任何一个，其组件都会被自动扫描，加入到容器中。</p>
<p>4、热加载：如果是<strong>方法内部的修改或者静态资源的修改</strong>，在 IDEA 中是可以通过 <strong>Rebuild</strong>（Ctrl + Shift + F9）进行热加载的；</p>
<p>5、遇到无法实例化的问题，到ComponentScan里面增加我们开发的项目路径；</p>
<p>6、PO层设置了mybatis自动注入时间，但是@TableField(fill&#x3D;FieldFill.INSERT)注解无法正常写入时间，需要检查MetaObjectHandler的具体实现，搞清楚自动注入的规则，可能只有固定的字段能被注入；</p>
<p>7、进入列模块编辑模式：SHIFT+ALT+INSERT</p>
<p>8、idea删除未使用的包快捷键： Ctrl + Alt + O</p>
<p>9、java: Can‘t generate mapping method with primitive return type.Mapper无法正常导入类：@Mapper导入的包出错了；</p>
<p>10、ctrl+shift+f全局搜；shift+shift搜索类；ctrl+shift+r全局替换；</p>
<p>11、mysql怎么批量杀死进程：<a href="https://blog.csdn.net/yanhang0610/article/details/52724009">https://blog.csdn.net/yanhang0610/article/details/52724009</a></p>
<p>12、idea环境下使用git提交代码、push代码，需要先checkout到remote的master分支，此基础上修改再提交可以成功，否则直接提交会显示用户为appuser@localhost被remote的库拒绝提交，且任务编号应处于正常状态；</p>
<p>13、Boolean和boolean的区别？</p>
<ul>
<li><code>Boolean</code> 是一个类，属于 <code>java.lang</code> 包，用于表示布尔值的封装类型。它提供了多个静态常量和方法，例如 <code>Boolean.TRUE</code> 和 <code>Boolean.FALSE</code>、valueOf（boolean b）。占用的内存更多，因为它是一个对象，包含了其他的信息，如哈希码等。</li>
<li><code>boolean</code> 是一个原始数据类型，用于直接存储布尔值，只有两个值true和false。是一个8位的值，在物理存储上只占用一个字节。</li>
</ul>
<p>14、按照DDD标准新增一个模块的全生命周期，需要至少需要新增17个类，其中11个class，6个interface；</p>
<p>15、MyBatis-Plus中LambdaQueryWrapper的使用详解：<a href="https://cloud.baidu.com/article/3314759">https://cloud.baidu.com/article/3314759</a></p>
<p><strong>参考链接：</strong></p>
<p>IDEA常用快捷键汇总：<a href="https://blog.csdn.net/weixin_45433031/article/details/106166961">https://blog.csdn.net/weixin_45433031/article/details/106166961</a></p>
<p>热加载、热重启：<a href="https://www.jb51.net/program/304976b3l.htm">https://www.jb51.net/program/304976b3l.htm</a></p>
<p>@TableField(fill&#x3D;FieldFill.INSERT)注解无法生效：<a href="https://blog.csdn.net/weixin_44892327/article/details/135935914">https://blog.csdn.net/weixin_44892327/article/details/135935914</a></p>
<p>Mapper导入的包出错：<a href="https://blog.csdn.net/qq_44980517/article/details/136235957">https://blog.csdn.net/qq_44980517/article/details/136235957</a></p>
<p>。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>研发脚手架初始环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>EP17-git踩坑记录</title>
    <url>/2024/10/09/EP17-git-learning-record/</url>
    <content><![CDATA[<h2 id="1、-lt-lt-lt-lt-lt-lt-lt-HEAD-gt-gt-gt-gt-gt-gt-gt-dev什么意思？"><a href="#1、-lt-lt-lt-lt-lt-lt-lt-HEAD-gt-gt-gt-gt-gt-gt-gt-dev什么意思？" class="headerlink" title="1、&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev什么意思？"></a>1、&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev什么意思？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">// 你的 &#x27;HEAD&#x27; 分支的代码</span><br><span class="line">=======</span><br><span class="line">// 你尝试合并的分支的代码</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></pre></td></tr></table></figure>

<p>这表示你遇到了一个合并冲突。Git 在尝试合并两个分支时，如果发现有相同的文件在两个分支中都有修改，但是修改的内容不一致，Git 就无法自动合并这些更改，这时候就需要你手动解决冲突。</p>
<span id="more"></span>

<p>这段标记的具体含义是：</p>
<ul>
<li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>：表示接下来的代码是你当前 <code>HEAD</code> 分支（即你正在合并到的分支）中的版本。</li>
<li><code>=======</code>：这是分隔符，用来区分不同分支的代码。</li>
<li><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</code>：表示上面的代码是你尝试合并的分支（在这个例子中是 <code>dev</code> 分支）中的版本。</li>
</ul>
<p>你需要决定要保留哪个版本的代码，或者结合两个版本的代码。解决冲突后，你需要使用以下命令来标记冲突已解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;解决合并冲突&quot;</span><br></pre></td></tr></table></figure>

<p>完成这些步骤后，合并冲突就会被视为已解决，你可以继续合并操作。</p>
<p>2、git常用命令</p>
<img src="/2024/10/09/EP17-git-learning-record/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8.jpg" class="" title="git常用命令速查表">

<p>参考链接：</p>
<p><a href="https://blog.csdn.net/bdfcfff77fa/article/details/145791820">https://blog.csdn.net/bdfcfff77fa/article/details/145791820</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>EP18-菜鸟教程-Java教程-学习笔记</title>
    <url>/2024/10/16/EP18-cainiao-java-learning/</url>
    <content><![CDATA[<p>此文档仅基于个人经验和感受出发，为菜鸟驿站-java教程的学习笔记。</p>
<p>课程参考链接：<a href="https://www.runoob.com/java/java-tutorial.html">https://www.runoob.com/java/java-tutorial.html</a></p>
<span id="more"></span>

<h2 id="一、Java基础语法-amp-Java注释"><a href="#一、Java基础语法-amp-Java注释" class="headerlink" title="一、Java基础语法&amp;Java注释"></a>一、Java基础语法&amp;Java注释</h2><h3 id="1、Java修饰符"><a href="#1、Java修饰符" class="headerlink" title="1、Java修饰符"></a>1、Java修饰符</h3><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>
<ul>
<li>访问控制修饰符 : default, public , protected, private</li>
<li>非访问控制修饰符 : final, abstract, static, synchronized</li>
</ul>
<h3 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h3><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p>
<p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（sub class）。</p>
<h3 id="3、接口"><a href="#3、接口" class="headerlink" title="3、接口"></a>3、接口</h3><p>在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p>
<p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>
<h3 id="4、Java-源程序与编译型运行区别"><a href="#4、Java-源程序与编译型运行区别" class="headerlink" title="4、Java 源程序与编译型运行区别"></a>4、Java 源程序与编译型运行区别</h3><p>如下图所示：</p>
<img src="/2024/10/16/EP18-cainiao-java-learning/ZSSDMld.png" class="" title="ZSSDMld">

<h3 id="5、文档注释"><a href="#5、文档注释" class="headerlink" title="5、文档注释"></a>5、文档注释</h3><p>文档注释以 <strong>&#x2F;*</strong>* 开始，以 ***&#x2F;** 结束，通常出现在类、方法、字段等的声明前面，用于生成代码文档，这种注释可以被工具提取并生成 API 文档，如 JavaDoc。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这是一个文档注释示例</span><br><span class="line"> * 它通常包含有关类、方法或字段的详细信息</span><br><span class="line"> */</span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    // 类的成员和方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档注释的格式通常包含一些特定的标签，如 <strong>@param</strong> 用于描述方法参数，**@return** 用于描述返回值，**@throws** 用于描述可能抛出的异常等等，这些标签有助于生成清晰的API文档，以便其他开发者能够更好地理解和使用你的代码。</p>
<h2 id="二、Java对象和类"><a href="#二、Java对象和类" class="headerlink" title="二、Java对象和类"></a>二、Java对象和类</h2><p><strong>4、封装（Encapsulation）</strong>：</p>
<ul>
<li><p>将对象的状态（字段）私有化，通过公共方法访问。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String name; </span><br><span class="line">public String getName() &#123; return name; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>5、多态（Polymorphism）</strong>：</p>
<ul>
<li><p>对象可以表现为多种形态，主要通过方法重载和方法重写实现。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 方法重载：`public int add(int a, int b) &#123; ... &#125;` 和 `public double add(double a, double b) &#123; ... &#125;`</span><br><span class="line"></span><br><span class="line">- 方法重写：`@Override public void makeSound() &#123; System.out.println(&quot;Meow&quot;); &#125;`</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>6、抽象（Abstraction）</strong>：</p>
<ul>
<li><p>使用抽象类和接口来定义必须实现的方法，不提供具体实现。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 抽象类：`public abstract class Shape &#123; abstract void draw(); &#125;`</span><br><span class="line"></span><br><span class="line">- 接口：`public interface Animal &#123; void eat(); &#125;`</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>9、方法重载（Method Overloading）</strong>：</p>
<ul>
<li><p>同一个类中可以有多个同名的方法，但参数不同。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MathUtils &#123;</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double add(double a, double b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>对象和类的概念。</p>
<ul>
<li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
</ul>
<h3 id="Java-中的类"><a href="#Java-中的类" class="headerlink" title="Java 中的类"></a>Java 中的类</h3><p>类可以看成是创建 Java 对象的模板。</p>
<img src="/2024/10/16/EP18-cainiao-java-learning/20210105-java-object-1.png" class="" title="20210105-java-object-1">

<p>一个类可以包含以下类型变量：</p>
<ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会<strong>为该类提供一个默认构造方法</strong>。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<p>下面是一个构造方法示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Puppy&#123;</span><br><span class="line">    public Puppy()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Puppy(String name)&#123;</span><br><span class="line">        // 这个构造器仅有一个参数：name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p>
<ul>
<li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li>
<li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li>
<li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li>
</ul>
<p>下面是一个创建对象的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Puppy&#123;</span><br><span class="line">   public Puppy(String name)&#123;</span><br><span class="line">      //这个构造器仅有一个参数：name</span><br><span class="line">      System.out.println(&quot;小狗的名字是 : &quot; + name ); </span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">      // 下面的语句将创建一个Puppy对象</span><br><span class="line">      Puppy myPuppy = new Puppy( &quot;tommy&quot; );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、DO、BO、DTO、VO、AO、PO、UID等术语解释"><a href="#三、DO、BO、DTO、VO、AO、PO、UID等术语解释" class="headerlink" title="三、DO、BO、DTO、VO、AO、PO、UID等术语解释"></a>三、DO、BO、DTO、VO、AO、PO、UID等术语解释</h2><p>在Java开发中，DO、BO、DTO、VO、AO、PO、UID等术语通常用于表示不同的对象类型或概念。以下是它们的常见含义：</p>
<ol>
<li><strong>DO (Data Object &#x2F; Domain Object)</strong>:<ul>
<li><strong>数据对象</strong>或<strong>领域对象</strong>，通常与数据库表直接对应，用于表示持久化数据。</li>
<li>例如，一个<code>UserDO</code>可能对应数据库中的<code>user</code>表。</li>
</ul>
</li>
<li><strong>BO (Business Object)</strong>:<ul>
<li><strong>业务对象</strong>，封装了业务逻辑和操作，通常由多个DO或其他BO组合而成。</li>
<li>例如，一个<code>OrderBO</code>可能包含订单信息、用户信息和商品信息。</li>
</ul>
</li>
<li><strong>DTO (Data Transfer Object)</strong>:<ul>
<li><strong>数据传输对象</strong>，用于在不同层（如服务层和表现层）之间传输数据。</li>
<li>例如，<code>UserDTO</code>可能包含用户的基本信息，用于前端展示。</li>
</ul>
</li>
<li><strong>VO (Value Object)</strong>:<ul>
<li><strong>值对象</strong>，通常用于表示一个不可变的对象，包含一些属性但没有行为。</li>
<li>例如，<code>AddressVO</code>可能包含地址的详细信息。</li>
</ul>
</li>
<li><strong>AO (Application Object)</strong>:<ul>
<li><strong>应用对象</strong>，用于表示应用程序中的某个实体或概念，通常包含业务逻辑。</li>
<li>例如，<code>ReportAO</code>可能表示一个报表对象，包含生成报表的逻辑。</li>
</ul>
</li>
<li><strong>PO (Persistent Object)</strong>:<ul>
<li><strong>持久化对象</strong>，与DO类似，通常用于表示与数据库表直接对应的对象。</li>
<li>例如，<code>UserPO</code>可能对应数据库中的<code>user</code>表。</li>
</ul>
</li>
<li><strong>UID (Unique Identifier)</strong>:<ul>
<li><strong>唯一标识符</strong>，用于唯一标识某个对象或实体。</li>
<li>例如，<code>userId</code>可能是一个用户的唯一标识符。</li>
</ul>
</li>
</ol>
<p>这些术语的具体使用可能因项目或团队的不同而有所差异，但它们的核心概念通常是相似的。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title>EP19-正则表达式基础知识点</title>
    <url>/2025/03/19/EP19-regular-expressions-basic-knowledge/</url>
    <content><![CDATA[<p>正则表达式是用于匹配、查找和操作文本的强大工具，通过定义特定模式来描述文本规则。</p>
<h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><h3 id="（一）字符匹配"><a href="#（一）字符匹配" class="headerlink" title="（一）字符匹配"></a>（一）字符匹配</h3><ol>
<li><p><strong>普通字符</strong>：直接匹配对应字符本身。例如，正则表达式 <code>abc</code> 能匹配字符串 “abc”，因为它精确匹配了这三个连续的字符。</p>
</li>
<li><p><strong>元字符</strong>：具有特殊含义的字符。例如，<code>.</code> 匹配除换行符 <code>\n</code> 之外的任意单个字符。正则表达式 <code>a.c</code> 可以匹配 “abc”、“a1c”、“a c” 等，只要中间字符是单个任意字符（除 <code>\n</code> 外）。</p>
<span id="more"></span></li>
</ol>
<h3 id="（二）字符类"><a href="#（二）字符类" class="headerlink" title="（二）字符类"></a>（二）字符类</h3><ol>
<li>**方括号 <code>[]</code>**：定义一个字符集合，匹配其中任意一个字符。例如，<code>[abc]</code> 可以匹配 “a”、“b” 或 “c”。还能使用范围表示，如 <code>[a - z]</code> 匹配任意小写字母，<code>[0 - 9]</code> 匹配任意数字。</li>
<li>**否定字符类 <code>[^]</code>**：匹配不在方括号内的任意一个字符。例如，<code>[^abc]</code> 可以匹配除 “a”、“b”、“c” 之外的任何字符。</li>
</ol>
<h3 id="（三）数量限定符"><a href="#（三）数量限定符" class="headerlink" title="（三）数量限定符"></a>（三）数量限定符</h3><ol>
<li>**<code>\*</code>**：匹配前面的元素零次或多次。例如，<code>a*</code> 可以匹配空字符串，也可以匹配 “a”、“aa”、“aaa” 等任意多个 “a” 组成的字符串。</li>
<li>**<code>+</code>**：匹配前面的元素一次或多次。例如，<code>a+</code> 至少匹配一个 “a”，能匹配 “a”、“aa”、“aaa” 等，但不能匹配空字符串。</li>
<li>**<code>?</code>**：匹配前面的元素零次或一次。例如，<code>a?</code> 可以匹配空字符串或 “a”。</li>
<li>**<code>&#123;n&#125;</code>**：匹配前面的元素恰好 <code>n</code> 次。例如，<code>a&#123;3&#125;</code> 只能匹配 “aaa”。</li>
<li>**<code>&#123;n,&#125;</code>**：匹配前面的元素至少 <code>n</code> 次。例如，<code>a&#123;3,&#125;</code> 能匹配 “aaa”、“aaaa”、“aaaaa” 等。</li>
<li>**<code>&#123;n,m&#125;</code>**：匹配前面的元素至少 <code>n</code> 次，最多 <code>m</code> 次。例如，<code>a&#123;2,4&#125;</code> 可以匹配 “aa”、“aaa”、“aaaa”。</li>
</ol>
<h2 id="二、边界匹配"><a href="#二、边界匹配" class="headerlink" title="二、边界匹配"></a>二、边界匹配</h2><ol>
<li>**<code>^</code>**：匹配字符串的开头。例如，<code>^abc</code> 只会匹配以 “abc” 开头的字符串，如 “abcdef”，而不会匹配 “defabc”。</li>
<li>**<code>$</code>**：匹配字符串的结尾。例如，<code>abc$</code> 只会匹配以 “abc” 结尾的字符串，如 “defabc”，而不会匹配 “abcdef”。</li>
<li>**<code>\b</code>**：匹配单词边界，即单词和非单词字符的分界处。例如，<code>\bcat\b</code> 可以匹配 “the cat is here” 中的 “cat”，但不会匹配 “category” 中的 “cat”。</li>
</ol>
<h2 id="三、分组与捕获"><a href="#三、分组与捕获" class="headerlink" title="三、分组与捕获"></a>三、分组与捕获</h2><ol>
<li>**分组 <code>()</code>**：将多个字符作为一个整体进行操作。例如，<code>(ab)+</code> 表示 “ab” 整体出现一次或多次，可以匹配 “ab”、“abab”、“ababab” 等。</li>
<li><strong>捕获组</strong>：括号内的表达式会被捕获，可以在后续通过索引（从 1 开始）来引用。例如，对于正则表达式 <code>(a)(b)</code>，在匹配 “ab” 后，<code>group(1)</code> 会返回 “a”，<code>group(2)</code> 会返回 “b”。</li>
</ol>
<h2 id="四、示例分析"><a href="#四、示例分析" class="headerlink" title="四、示例分析"></a>四、示例分析</h2><p>假设要从字符串 “USD:352677,33.00” 中提取出 “USD” 和 “352677,33.00” 两部分，使用正则表达式 <code>([A-Z]&#123;3&#125;):(\\d&#123;1,3&#125;(,\\d&#123;3&#125;)*\\.\\d&#123;2&#125;)</code>。</p>
<ol>
<li>**<code>([A-Z]&#123;3&#125;)</code>**：这是第一个捕获组，<code>[A-Z]</code> 表示所有大写字母的字符类，<code>&#123;3&#125;</code> 限定前面的字符类要出现 3 次，所以它会匹配到 “USD” 这样的三位大写字母组合，通过 <code>group(1)</code> 可获取 “USD”。</li>
<li>**<code>:</code>**：匹配字符串中的冒号。</li>
<li>**<code>(\\d&#123;1,3&#125;(,\\d&#123;3&#125;)\*\\.\\d&#123;2&#125;)</code>**：这是第二个捕获组，<code>\\d&#123;1,3&#125;</code> 匹配金额整数部分开头的 1 到 3 位数字，<code>(,\\d&#123;3&#125;)*</code> 匹配可能存在的千分位分隔符及后续 3 位数字，<code>*</code> 表示可以有零个或多个这样的组合，<code>\\.\\d&#123;2&#125;</code> 匹配小数点及后面两位数字。整体匹配 “352677,33.00” 这样格式的金额，通过 <code>group(2)</code> 可获取该金额字符串。</li>
</ol>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>java开发</tag>
      </tags>
  </entry>
  <entry>
    <title>EP20-《阿里巴巴Java开发手册》读书笔记</title>
    <url>/2025/03/20/EP20-alibaba-java-readnote/</url>
    <content><![CDATA[<h2 id="第1章-编程规约"><a href="#第1章-编程规约" class="headerlink" title="第1章　编程规约"></a>第1章　编程规约</h2><p>本章是传统意义上的代码规范，包括变量命名、代码风格、控制语句、代码注释、前后端规约等基本的编程习惯，以及从高并发场景中提炼出来的集合处理技巧与并发多线程的注意事项。</p>
<h3 id="1-2-常量定义"><a href="#1-2-常量定义" class="headerlink" title="1.2 常量定义"></a>1.2 常量定义</h3><ol>
<li>不要使用一个常量类维护所有的常量，要按常量功能进行归类，分开维护。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明：大而全的常量类杂乱无章，必须使用查找功能才能定位到要修改的常量，既不利于理解，也不利于维护。</span><br><span class="line">正例：缓存相关常量放在类CacheConsts下；系统配置相关常量放在类SystemConfigConsts下。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量和类内共享常量。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）跨应用共享常量：放置在二方库中，通常是在client.jar中的constant目录下。</span><br><span class="line">2）应用内共享常量：放置在一方库中，通常是在子模块中的constant目录下。</span><br><span class="line">3）子工程内部共享常量：即在当前子工程的constant目录下。</span><br><span class="line">4）包内共享常量：即在当前包下单独的constant目录下。</span><br><span class="line">5）类内共享常量：直接在类内部以private static final定义。</span><br></pre></td></tr></table></figure>

<h3 id="1-3代码格式"><a href="#1-3代码格式" class="headerlink" title="1.3代码格式"></a>1.3代码格式</h3><ol>
<li>if&#x2F;for&#x2F;while&#x2F;switch&#x2F;do等保留字与括号之间都必须加空格。</li>
<li>任何二目、三目运算符的左右两边都需要加一个空格。</li>
<li>注释的双斜线与注释内容之间有且仅有一个空格。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  这是一个示例注释，双斜线之后有一个空格</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在进行类型强制转换时，右括号与被强制转换的值之间不需要任何空格隔开。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double first = 3.14d;</span><br><span class="line">int second = (int)first + 2;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在定义和传入方法参数时，多个参数逗号后面必须加空格。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">method(arg1, arg2, arg3);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>单个方法的总行数不超过80。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码逻辑分清红花和绿叶、个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护。</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在不同逻辑、不同语义、不同业务的代码之间插入一个空行，分隔开来以提升可读性。</li>
</ol>
<h3 id="1-4-OOP规约（object-oriented-programming-）"><a href="#1-4-OOP规约（object-oriented-programming-）" class="headerlink" title="1.4 OOP规约（object-oriented programming ）"></a>1.4 OOP规约（<strong>object-oriented programming</strong> ）</h3><ol>
<li><p>避免通过一个类的对象引用访问此类的静态变量或静态方法，造成编译器解析成本无谓增加，直接用类名访问即可。</p>
</li>
<li><p>对外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。若接口过时，则必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。</p>
</li>
<li><p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象调用equals。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;test&quot;</span>.equals(object);<span class="comment">//正例</span></span><br><span class="line">object.equals(<span class="string">&quot;test&quot;</span>);<span class="comment">//反例</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>浮点数之间的等值判断，基本数据类型不能用&#x3D;&#x3D;进行比较，包装数据类型不能用equals方法判断。</p>
<p>说明：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分十进制小数，具体原理参考《码出高效：Java开发手册》。</p>
<img src="/2025/03/20/EP20-alibaba-java-readnote/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9B%B8%E5%87%8F%E4%BE%8B%E5%AD%90.png" class="" title="浮点数相减例子">
</li>
<li><p>禁止使用构造方法BigDecimal(double)的方式把double值转化为BigDecimal对象。</p>
<p><strong>说明：</strong>BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中，可能会导致业务逻辑出现异常。</p>
</li>
<li><p>在定义DO&#x2F;DTO&#x2F;VO等POJO类时，不要设定任何属性默认值。</p>
</li>
<li><p>禁止在POJO类中同时存在对应属性xxx的isXxx()和getXxx()方法。</p>
<p><strong>说明：</strong>框架在调用属性xxx的提取方法时，并不能确定哪种方法一定是被优先调用的。</p>
</li>
<li><p>当使用索引访问用String的split方法得到的数组时，需在最后一个分隔符后做有无内容的检查，否则会有抛出IndexOutOfBoundsException的风险。</p>
</li>
<li><p>当一个类有多个构造方法，或者多个同名方法时，这些方法应该按顺序放置在一起，便于阅读。优先于第<strong>10</strong>条规则。</p>
</li>
<li><p>类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter &#x2F; setter方法。</p>
<p><strong>说明：</strong>公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有Service和DAO的getter&#x2F;setter方法都放在类体的最后。</p>
</li>
<li><p>在循环体内，字符串的连接方式使用StringBuilder的append方法扩展。</p>
</li>
<li><p>final可以声明类、成员变量、方法及本地变量，下列情况使用final关键字。</p>
<p>1）<strong>不允许被继承</strong>的类，如：String类。</p>
<p>2）<strong>不允许修改引用</strong>的域对象，如：POJO类的域变量。</p>
<p>3）<strong>不允许被覆写</strong>的方法，如：POJO类的setter方法。</p>
<p>4）<strong>不允许</strong>在运行过程中给<strong>局部变量重新赋值</strong>。</p>
<p>5）<strong>避免上下文重复使用一个变量</strong>，使用final描述可以强制重新定义一个变量，方便更好地重构。</p>
</li>
<li><p>慎用Object的clone方法拷贝对象。</p>
<p><strong>说明：</strong>对象的clone方法默认是浅拷贝，若想实现深拷贝，需要覆写clone方法来实现域对象的深度遍历式拷贝。</p>
</li>
</ol>
<h3 id="1-5-日期时间"><a href="#1-5-日期时间" class="headerlink" title="1.5　日期时间"></a>1.5　日期时间</h3><ol>
<li><p>在日期格式化时，传入pattern中表示年份统一使用小写的y。</p>
<p><strong>说明：</strong>在日期格式化时，yyyy表示当天所在的年，大写的YYYY表示week in which year（JDK 7之后引入的概念），意思是当天所在的周属于的年份。一周从周日开始，周六结束，只要本周跨年，返回的YYYY就是下一年。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在日期格式中，分清楚大写的M和小写的m、大写的H和小写的h分别代表的意义。</p>
<p><strong>说明：</strong>日期格式中的这两对字母表意如下：1）表示月份，用大写的M；2）表示分钟，用小写的m；3）表示24小时制，用大写的H；4）表示12小时制，用小写的h。</p>
</li>
<li><p>不要在程序中写死一年为365天，避免在闰年时出现日期转换错误或程序逻辑错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取今年的天数</span><br><span class="line">int days = LocalDate.now().lengthOfYear();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用枚举值指代月份。如果使用数字，则注意Date、Calendar等日期相关类的月份（month）取值在0～11之间。</p>
<p><strong>说明：</strong>参考JDK原生注释，Month value is 0-based.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e.g. 0 for January</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-6-集合处理"><a href="#1-6-集合处理" class="headerlink" title="1.6　集合处理"></a>1.6　集合处理</h3><ol>
<li><p>判断所有集合内部的元素是否为空，应使用isEmpty()方法，而不是使用size()&#x3D;&#x3D;0的方式。</p>
<p><strong>说明：</strong>在某些集合中，前者的时间复杂度为O(1)，而且可读性更好。</p>
</li>
<li><p>在使用java.util.stream.Collectors类的toMap()方法转为Map集合时，一定要使用含有参数类型为BinaryOperator、参数名为mergeFunction的方法，否则当出现相同key值时，会抛出IllegalStateException异常。</p>
<p><strong>说明：</strong>参数mergeFunction的作用是当出现key重复时，自定义对value的处理策略。</p>
</li>
<li><p>在使用java.util.stream.Collectors类的toMap()方法转为Map集合时，一定要注意当value为null时，会抛出NPE异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">会存在如下判断：</span><br><span class="line">if (value == null || remappingFunction == null)&#123;</span><br><span class="line">	throw new NullPointerException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常，即java.util. RandomAccessSubList cannot be cast to java.util. ArrayList。</p>
<p><strong>说明：</strong>subList()返回的是ArrayList的内部类SubList，并不是ArrayList本身，而是ArrayList的一个视图，对于SubList的所有操作最终会反映到原列表上。</p>
</li>
<li><p>Collections类返回的对象，如：emptyList()&#x2F; singletonList()等都是immutable list，不可对其添加或者删除元素。</p>
</li>
<li><p>在使用Collection接口任何实现类的addAll()方法时，都要对输入的集合参数进行NPE判断。</p>
<p><strong>说明：</strong>ArrayList#addAll方法的第一行代码即Object[] a &#x3D; c. toArray();，其中，c为输入集合参数，如果为null，则直接抛出异常。</p>
</li>
<li><p>当使用工具类Arrays.asList()把<strong>数组转换成集合时，不能使用其修改集合相关的方法</strong>，它的add&#x2F;remove&#x2F;clear方法会抛出UnsupportedOperationException异常。</p>
<p><strong>说明：</strong>asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p>
</li>
<li><p>在无泛型限制定义的集合赋值给泛型限制的集合中，当使用集合元素时，需要进行instanceof判断，避免抛出ClassCastException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无泛型限制的集合：可以存储任意类型的对象，但取出时需要手动进行类型转换，容易引发ClassCastException</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 可以存储不同类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>); <span class="comment">// 需要强制类型转换</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> (Integer) list.get(<span class="number">1</span>); <span class="comment">// 需要强制类型转换</span></span><br><span class="line"><span class="comment">// 泛型限制的集合</span></span><br><span class="line">List&lt;String&gt; genericList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">genericList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// genericList.add(123); // 编译错误，只能存储String类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> genericList.get(<span class="number">0</span>); <span class="comment">// 无需强制类型转换</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在foreach循环中对元素进行remove&#x2F;add操作。当进行remove操作时，请使用Iterator方式。如果是并发操作，需要对Iterator对象加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个集合</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取 Iterator 对象</span></span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="comment">// 遍历集合</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> iterator.next(); <span class="comment">// 获取下一个元素</span></span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">        <span class="comment">// 如果需要，可以移除当前元素</span></span><br><span class="line">        <span class="keyword">if</span> (fruit.equals(<span class="string">&quot;Banana&quot;</span>)) &#123;</span><br><span class="line">            iterator.remove(); <span class="comment">// 移除 &quot;Banana&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出修改后的集合</span></span><br><span class="line">    System.out.println(<span class="string">&quot;修改后的集合: &quot;</span> + list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当使用泛型集合定义时，在JDK 7及以上版本中，使用diamond语法或全省略。</p>
<p><strong>说明：</strong>菱形泛型即diamond，直接使用&lt;&gt;指代前边已经指定的类型。</p>
</li>
<li><p>使用entrySet遍历Map类集合K&#x2F;V，而不是用keySet方式遍历。</p>
<p><strong>说明：</strong>keySet方式其实遍历了两次，一次是转为Iterator对象，另一次是从hashMap中取出Key所对应的Value。而entrySet只遍历了一次就把Key和Value都放到了entry中，效率更高。如果是JDK 8，则使用Map.forEach方法。</p>
<p><strong>正例：</strong>values()返回的是V值集合，是一个list集合对象；keySet()返回的是K值集合，是一个Set集合对象；entrySet()返回的是K-V值组合集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Map 集合</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Apple&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Banana&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Cherry&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 使用 keySet 方式遍历（不推荐，效率较低）</span></span><br><span class="line">        	<span class="comment">// (1)通过 map.keySet() 获取所有的 Key，然后遍历 Key。每次遍历时，需要通过 map.get(key) 从 Map 中获取对应的 Value。</span></span><br><span class="line">        	<span class="comment">// (2)缺点：遍历了两次，第一次遍历 Key，第二次通过 Key 获取 Value，效率较低。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 keySet 方式遍历：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key); <span class="comment">// 需要额外从 Map 中获取 Value</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用 entrySet 方式遍历（推荐，效率更高）</span></span><br><span class="line">        	<span class="comment">//(1)通过 map.entrySet() 获取所有的 Map.Entry 对象。每个 Map.Entry 对象包含一个 Key 和对应的 Value。</span></span><br><span class="line">        	<span class="comment">//(2)优点：只需遍历一次，直接从 Entry 中获取 Key 和 Value，效率更高。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n使用 entrySet 方式遍历：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue(); <span class="comment">// 直接从 Entry 中获取 Key 和 Value</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用 JDK 8 的 forEach 方法（推荐，代码更简洁）</span></span><br><span class="line">        	<span class="comment">//(1)使用 map.forEach((key, value) -&gt; &#123; ... &#125;) 方法，直接遍历 Key 和 Value。</span></span><br><span class="line">        	<span class="comment">//(2)优点：代码更简洁，可读性更高。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n使用 JDK 8 的 forEach 方法遍历：&quot;</span>);</span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高度注意Map类集合K&#x2F;V能否存储null值，如表1-1所示。</p>
<img src="/2025/03/20/EP20-alibaba-java-readnote/Map%E7%B1%BB%E9%9B%86%E5%90%88KV%E5%AD%98%E5%82%A8.jpg" class="" title="Map类集合KV存储">
</li>
<li><p>合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。</p>
<p><strong>说明：</strong>有序性指遍历的结果按某种比较规则依次排列。稳定性指集合每次遍历的元素次序是一定的。如：<strong>ArrayList是order&#x2F;unsort；HashMap是unorder&#x2F;unsort；TreeSet是order&#x2F;sort</strong>。</p>
</li>
<li><p>利用<strong>Set元素</strong>唯一的特性，可以<strong>快速对一个集合进行去重操作</strong>，避免使用List的contains()进行遍历、去重或者判断包含操作。</p>
</li>
</ol>
<h3 id="1-7-并发处理"><a href="#1-7-并发处理" class="headerlink" title="1.7　并发处理"></a>1.7　并发处理</h3><ol>
<li><p>当创建线程或线程池时，请指定有意义的线程名称，出错时方便回溯。</p>
<blockquote>
<ul>
<li><p>（1）为单个线程指定名称：在创建 <code>Thread</code> 时，通过构造方法的第二个参数指定线程名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NamedThreadExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建一个线程，并指定有意义的名称</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;线程正在执行任务...&quot;);</span><br><span class="line">            // 模拟任务执行</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;File-Processing-Thread&quot;); // 指定线程名称为 &quot;File-Processing-Thread&quot;</span><br><span class="line"></span><br><span class="line">        // 启动线程</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        // 打印线程名称</span><br><span class="line">        System.out.println(&quot;线程名称: &quot; + thread.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>（2）为线程池指定线程名称：使用自定义的 <code>ThreadFactory</code>，在 <code>newThread</code> 方法中为线程指定名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class NamedThreadPoolExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 自定义线程工厂，为线程池中的线程指定有意义的名称</span><br><span class="line">        ThreadFactory threadFactory = new ThreadFactory() &#123;</span><br><span class="line">            private int count = 0;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Thread newThread(Runnable r) &#123;</span><br><span class="line">                return new Thread(r, &quot;Task-Thread-&quot; + (++count)); // 指定线程名称</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 创建线程池，使用自定义的线程工厂</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(3, threadFactory);</span><br><span class="line"></span><br><span class="line">        // 提交任务到线程池</span><br><span class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            int taskId = i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;任务 &quot; + taskId + &quot; 正在由线程 &quot; + Thread.currentThread().getName() + &quot; 执行&quot;);</span><br><span class="line">                // 模拟任务执行</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 关闭线程池</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>（3）使用 Guava 的 <code>ThreadFactoryBuilder</code>（推荐）：更方便地指定线程名称格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.google.common.util.concurrent.ThreadFactoryBuilder;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class GuavaThreadPoolExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 使用 Guava 的 ThreadFactoryBuilder 创建线程工厂</span><br><span class="line">        ThreadFactory threadFactory = new ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(&quot;Guava-Thread-%d&quot;) // 指定线程名称格式</span><br><span class="line">                .build();</span><br><span class="line">        // 创建线程池，使用 Guava 的线程工厂</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(3, threadFactory);</span><br><span class="line">        // 提交任务到线程池</span><br><span class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            int taskId = i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;任务 &quot; + taskId + &quot; 正在由线程 &quot; + Thread.currentThread().getName() + &quot; 执行&quot;);</span><br><span class="line">                // 模拟任务执行</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 关闭线程池</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
</li>
<li><p>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>
<p><strong>说明：</strong>使用线程池的好处是减少在创建和销毁线程上消耗的时间及系统资源，解决资源不足的问题。如果不使用线程池，则有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
</li>
<li><p>SimpleDateFormat是线程不安全的类，一般不要定义为static变量，如果定义为static，则必须加锁，或者使用DateUtils工具类。</p>
<p><strong>说明：</strong>如果是JDK 8的应用，可以使用Instant代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替SimpleDateFormat。官方给出的解释：simple beautiful strong immutable thread-safe。</p>
</li>
<li><p>必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的ThreadLocal变量，则可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用try-finally块回收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objectThreadLocal.set(userInfo);</span><br><span class="line">try&#123;</span><br><span class="line">	//代码省略</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	objectThreadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在高并发场景中，同步调用应该考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p>
<p><strong>说明：</strong>使加<strong>锁的代码块工作量尽可能的小</strong>，避免在锁代码块中调用RPC方法。</p>
<blockquote>
<p><strong>RPC（Remote Procedure Call，远程过程调用）</strong> 是一种允许程序调用远程服务器上的方法或函数的机制，就像调用本地方法一样。RPC 的核心思想是隐藏网络通信的复杂性，使开发者能够像调用本地方法一样调用远程服务。</p>
</blockquote>
</li>
<li><p>在对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</p>
<p><strong>说明：</strong>如果线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。</p>
</li>
<li><p>在使用阻塞<strong>等待获取锁的方式中，必须在try代码块之外</strong>，并且在加锁方法与try代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在finally中无法解锁。</p>
<p><strong>说明一：</strong>如果在lock方法与try代码块之间的方法调用抛出异常，那么无法解锁，造成其他线程无法成功获取锁。</p>
<p><strong>说明二：</strong>如果lock方法在try代码块之内，可能由于其他方法抛出异常，导致在finally代码块中，unlock对未加锁的对象尝试解锁，它会调用AQS的try Release方法（取决于具体实现类），抛出Illegal MonitorStateException异常。</p>
<p><strong>说明三：</strong>在Lock对象的lock方法实现中，可能抛出unchecked异常，产生的后果与说明二相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock lock = new XxxLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">	doSomething();</span><br><span class="line">	doOthers();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在并发修改同一记录时，为避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存层加锁，要么在数据库层使用乐观锁，使用version作为更新依据。</p>
<p><strong>说明：</strong>如果每次访问冲突概率小于20%，则推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。</p>
</li>
<li><p>与资金相关的金融敏感信息，使用悲观锁策略。</p>
<p><strong>说明：</strong>乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞。另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以与资金相关的金融敏感信息不建议使用乐观锁更新。</p>
<blockquote>
<p><strong>正例：</strong>悲观锁遵循“一锁二判三更新四释放”的原则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新产品价格，使用乐观锁机制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateProductPriceWithRetry</span><span class="params">(Long productId, BigDecimal newPrice)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retryCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxRetries</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// 最少重试3次</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (retryCount &lt; maxRetries) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 查询当前产品和版本号</span></span><br><span class="line">                <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> jdbcTemplate.queryForObject(</span><br><span class="line">                    <span class="string">&quot;SELECT id, name, price, version FROM products WHERE id = ?&quot;</span>,</span><br><span class="line">                    (rs, rowNum) -&gt; <span class="keyword">new</span> <span class="title class_">Product</span>(</span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">                        rs.getBigDecimal(<span class="string">&quot;price&quot;</span>),</span><br><span class="line">                        rs.getInt(<span class="string">&quot;version&quot;</span>)</span><br><span class="line">                    ),</span><br><span class="line">                    productId</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2. 执行更新操作，带上version条件</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">updatedRows</span> <span class="operator">=</span> jdbcTemplate.update(</span><br><span class="line">                    <span class="string">&quot;UPDATE products SET price = ?, version = version + 1 WHERE id = ? AND version = ?&quot;</span>,</span><br><span class="line">                    newPrice, productId, product.getVersion()</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 3. 检查是否更新成功</span></span><br><span class="line">                <span class="keyword">if</span> (updatedRows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 更新成功</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 4. 如果没有更新任何行，说明version不匹配，数据已被其他事务修改</span></span><br><span class="line">                retryCount++;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 短暂等待后重试</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">catch</span> (EmptyResultDataAccessException e) &#123;</span><br><span class="line">                <span class="comment">// 产品不存在</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;更新被中断&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试3次后仍然失败</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockingFailureException</span>(<span class="string">&quot;更新产品价格失败，经过&quot;</span> + maxRetries + <span class="string">&quot;次重试后仍无法完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 产品实体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> version;</span><br><span class="line">    <span class="comment">// 构造方法、getter和setter省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>使用CountDownLatch进行异步转同步操作，每个线程在退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，直到超时才返回结果。</p>
<p><strong>说明：</strong>子线程抛出异常堆栈，不能在主线程try-catch到。</p>
</li>
<li><p><strong>避免Random实例被多线程使用，</strong>虽然共享该实例是线程安全的，但会因竞争同一seed导致性能下降。</p>
<p><strong>说明：</strong>Random实例包括java.util.Random的实例或者Math. random()的方式。<strong>正例：</strong>在JDK 7之后，可以直接使用API ThreadLocalRandom；而在JDK 7之前，需要编码保证每个线程持有一个单独的Random实例。</p>
</li>
<li><p>ThreadLocal对象使用static修饰，Thread Local无法解决共享对象的更新问题。</p>
<p><strong>说明：</strong>这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说，在类第一次被使用时装载，只分配一块存储空间，所有此类的对象（只要是这个线程内定义的）都可以操控这个变量。</p>
</li>
</ol>
<h3 id="1-8-控制语句"><a href="#1-8-控制语句" class="headerlink" title="1.8  控制语句"></a>1.8  控制语句</h3><ol>
<li><p>在一个switch块内，每个case要么通过continue&#x2F; break&#x2F;return等终止，要么注释说明程序将继续执行到哪一个case为止。一个switch块内必须包含一个default语句并且放在最后，即使它什么代码也没有。</p>
<p><strong>说明：</strong>break是退出switch语句块，而return是退出方法体。</p>
</li>
<li><p>当switch括号内的变量类型为String并且此变量为外部参数时，必须先进行null判断。</p>
</li>
<li><p>在三目运算符condition? 表达式1 : 表达式2中，注意表达式1和表达式2在类型对齐时，可能抛出自动拆箱导致的NPE异常。</p>
<p><strong>说明：</strong>以下两种场景会触发类型对齐的拆箱操作：</p>
<p>1）表达式1或表达式2的值有一个是原始类型。</p>
<p>2）表达式1或表达式2的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。</p>
</li>
<li><p>在高并发场景中，避免使用“等于”判断作为中断或退出的条件。</p>
<p><strong>说明：如果没有处理好并发控制，容易产生等值判断被“击穿”的情况</strong>，使用大于或小于的区间判断条件来代替。</p>
<p><strong>反例：</strong>当判断剩余奖品数量等于0时，终止发放奖品，但因为并发处理错误，导致奖品数量瞬间变成了负数，这样的话活动将无法终止。</p>
</li>
<li><p>表达异常的分支时，尽量少用if-else方式，这种方式可以改写成：</p>
<p><strong>说明：</strong>如果不得不使用if()…else if()…else…方式表达逻辑，那么为【强制】避免后续代码维护困难，请勿超过3层。</p>
</li>
<li><p>除常用方法（如getXxx&#x2F;isXxx）外，不要在条件判断中执行其他复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。</p>
<p><strong>说明：</strong>很多if语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人赏心悦目的事情。</p>
</li>
<li><p>不要在其他表达式（尤其是条件表达式）中插入赋值语句。</p>
<p><strong>说明：</strong>赋值点类似于人体的穴位，对于代码的理解至关重要，所以赋值语句需要清晰地单独成为一行。</p>
</li>
<li><p>避免采用取反逻辑运算符。</p>
<p><strong>说明：</strong>取反逻辑不利于快速理解，并且取反逻辑写法一般都存在对应的正向逻辑写法。</p>
</li>
<li><p>公开接口需要进行入参保护，尤其是批量操作的接口。</p>
<p><strong>反例：</strong>某业务系统，提供一个用户批量查询的接口，API文档上有说最多查多少个，但接口实现上没做任何保护，导致调用方传了一个1000的用户id数组，查询信息后，内存爆满。</p>
</li>
</ol>
<h3 id="1-9-注释规约"><a href="#1-9-注释规约" class="headerlink" title="1.9  注释规约"></a>1.9  注释规约</h3><ol>
<li><p>类、类属性、类方法的注释必须使用Javadoc规范，使用&#x2F;*<em>内容</em>&#x2F;格式，不得使用&#x2F;&#x2F; xxx方式。</p>
<p><strong>说明：</strong>在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，当工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</p>
</li>
<li><p>所有的类都必须添加创建者和创建日期。</p>
<p><strong>说明：</strong>在设置模板时，注意IDEA的@author为’${USER}’，而eclipse的@author为’${user}’，大小写有区别。日期的设置统一为yyyy&#x2F;MM&#x2F;dd的格式。</p>
</li>
<li><p>与其用“半吊子”英文注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</p>
<p><strong>反例：</strong>将“TCP连接超时”解释成“传输控制协议连接超时”，理解起来反而费脑筋。</p>
</li>
<li><p>谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。</p>
<p><strong>说明：</strong>代码被注释掉有两种可能：</p>
<p>1）后续会恢复此段代码逻辑；</p>
<p>2）永久不用。</p>
<p>前者如果没有备注信息，则难以知晓注释动机。后者建议直接删除，假如需要查阅历史代码，登录代码仓库即可。</p>
</li>
<li><p>对于注释的要求。</p>
<p>1）能够准确反映设计思想和代码逻辑。</p>
<p>2）能够描述业务含义，使其他程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释既是给自己看的，即使隔很长时间，也能清晰理解当时的思路；也是给继任者看的，使其能够快速接替自己的工作。</p>
</li>
<li><p>特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。有时候线上故障就来源于这些标记处的代码。</p>
<p>1）待办事宜（TODO）:（标记人，标记时间，[预计处理时间]）。</p>
<p>表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，虽然目前的Javadoc还没有实现，但已经被广泛使用。只能应用于类、接口和方法（因为它是一个Javadoc标签）。</p>
<p>2）错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）。</p>
<p>在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p>
</li>
</ol>
<h3 id="1-10-前后端规约"><a href="#1-10-前后端规约" class="headerlink" title="1.10 前后端规约"></a>1.10 前后端规约</h3><ol>
<li><p>前后端数据列表相关的接口返回，如果为空，则返回空数组[]或空集合{}。</p>
<p><strong>说明：</strong>此条约定有利于数据层面上的协作更加高效，减少前端很多琐碎的null判断。</p>
</li>
<li><p>当服务端发生错误时，返回给前端的响应信息必须包含HTTP状态码、errorCode、errorMessage和用户提示信息四部分。</p>
<p><strong>说明：</strong>四部分的涉众对象分别是浏览器、前端开发、错误排查人员、用户。其中输出给用户的提示信息要求：简短清晰、提示友好，引导用户进行下一步操作或解释错误原因，提示信息可以包括错误原因、上下文环境、推荐操作等。errorMessage：简要描述后端出错原因，便于错误排查人员快速定位问题，注意不要包含敏感数据信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：常见的HTTP状态码如下。</span><br><span class="line">1）200 OK: 表明该请求被成功地完成，所请求的资源发送到客户端。</span><br><span class="line">2）401 Unauthorized: 请求要求身份验证，常见于需要登录而用户未登录的情况。</span><br><span class="line">3）403 Forbidden：服务器拒绝请求，常见于机密信息或通过复制其他登录用户链接访问服务器的情况。</span><br><span class="line">4）404 Not Found: 服务器无法获得所请求的网页，请求资源不存在。</span><br><span class="line">5）500 Internal Server Error: 服务器内部错误。</span><br></pre></td></tr></table></figure>
</li>
<li><p>当HTTP请求通过URL传递参数时，不能超过2048字节。</p>
<p><strong>说明：</strong>不同浏览器对于URL的最大长度限制略有不同，并且对超出最大长度的处理逻辑也有差异，2048字节是取所有浏览器的最小值。</p>
<p><strong>反例：</strong>某业务将退货的商品id列表放在URL中作为参数传递，当一次退货商品数量过多时，URL参数超长，传递到后端的参数被截断，导致部分商品未能正确退货。</p>
</li>
<li><p>HTTP请求通过body传递内容时，必须控制长度，超出最大长度后，后端解析会出错。</p>
<p><strong>说明：</strong>Nginx默认限制为1MB，Tomcat默认限制为2MB，当确实有业务需要传递较多内容时，可以调大服务器端的限制。</p>
</li>
<li><p>服务端返回的数据，使用JSON格式而非XML。</p>
<p><strong>说明：</strong>尽管HTTP支持使用不同的输出格式，例如纯文本、JSON、CSV、XML、RSS甚至HTML。但如果我们使用面向用户的服务，那么应该选择JSON</p>
</li>
<li><p>前后端的时间格式统一为”yyyy-MM-dd HH:mm:ss”，为GMT。</p>
</li>
</ol>
<h3 id="1-11-其他"><a href="#1-11-其他" class="headerlink" title="1.11　其他"></a>1.11　其他</h3><ol>
<li><p>避免用Apache Beanutils进行属性的copy。</p>
<p><strong>说明：</strong>Apache BeanUtils性能较差，可以使用其他方案，比如Spring BeanUtils、Cglib BeanCopier，注意均是浅拷贝。</p>
</li>
<li><p>注意Math.random()方法返回的是double类型，取值的范围0≤x&lt;1（能够取到零值，注意除零异常）。如果想获取整数类型的随机数，不要将x放大10的若干倍后再取整，直接使用Random对象的nextInt或者nextLong方法即可。</p>
</li>
<li><p>不要在视图模板中加入任何复杂的逻辑。</p>
<p><strong>说明：</strong>根据MVC理论，视图的职责是展示，不要抢模型和控制器的工作。</p>
</li>
<li><p>及时清理不再使用的代码段或配置信息。</p>
<p><strong>说明：</strong>对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。</p>
<img src="/2025/03/20/EP20-alibaba-java-readnote/%E6%B3%A8%E9%87%8A%E4%BB%A3%E7%A0%81%E7%9A%84%E8%A7%84%E7%BA%A6.png" class="" title="注释代码的规约"></li>
</ol>
<h2 id="第2章-异常日志"><a href="#第2章-异常日志" class="headerlink" title="第2章　异常日志"></a>第2章　异常日志</h2><p>异常处理是大部分程序员多年的痛点，本章主要涉及如何定义错误码，定义异常对象、捕获、处理异常事件，如何以合理的日志结构保存出错现场信息，以便快速定位问题。</p>
<h3 id="2-1-错误码"><a href="#2-1-错误码" class="headerlink" title="2.1　错误码"></a>2.1　错误码</h3><ol>
<li><p>错误码的制订原则：快速溯源、沟通标准化。</p>
<p><strong>说明：</strong>错误码设计得过于完美和复杂，就像字典中的生僻字一样，虽然表意精准，但是不易懂。</p>
<p><strong>正例：</strong>错误码回答“谁的错？”“错在哪？”的问题。</p>
<p>1）错误码必须能够快速知晓错误来源，可快速判断是谁的问题。</p>
<p>2）错误码必须能够清晰地比对（代码中容易equals）。</p>
<p>3）错误码有利于团队快速对错误原因达成一致。</p>
</li>
<li><p>当全部正常，但不得不填充错误码时，返回五个零（00000）。</p>
</li>
<li><p>错误码为字符串类型，共5位，分为错误产生来源、四位数字编号两部分。</p>
<p><strong>说明：</strong>错误产生来源分为A、B、C三种，A表示错误来源于用户，例如参数错误、用户安装版本过低、用户支付超时等；B表示错误来源于当前系统，例如业务逻辑出错、程序健壮性差等；C表示错误来源于第三方服务，例如CDN服务出错、消息投递超时等；四位数字编号从0001到9999，大类之间的步长间距预留100。</p>
</li>
<li><p>错误码使用者避免随意定义新的错误码。</p>
<p><strong>说明：</strong>在代码中使用错误码时，尽可能在原有错误码附表中找到语义相同或者相近的错误码。</p>
</li>
<li><p>错误码不能直接输出给用户作为提示信息使用。</p>
<p><strong>说明：</strong>堆栈、错误码（errorCode）、错误信息(errorMessage)、提示信息（userTip）是一个有效关联并互相转义的和谐整体，但请勿越俎代庖。</p>
</li>
<li><p>错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。</p>
<p><strong>说明：</strong>在无法确定的错误场景中，可以直接使用一级宏观错误码，分别是：A0001（用户端错误）、B0001（系统执行出错）、C0001（调用第三方服务出错）。</p>
<p><strong>正例：</strong>调用第三方服务出错是一级，中间件出错是二级，消息服务出错是三级。</p>
</li>
</ol>
<h3 id="2-2-异常处理"><a href="#2-2-异常处理" class="headerlink" title="2.2　异常处理"></a>2.2　异常处理</h3><ol>
<li><p>Java类库中定义的可以通过预检查方式规避的RuntimeException不应该通过catch的方式处理，如：NullPointerException、IndexOutOfBoundsException等。</p>
<p><strong>说明：</strong>无法通过预检查的异常不在此列，比如当解析字符串形式的数字时，可能存在数字格式错误，通过catch NumberFormatException实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：if (obj!=null) &#123;...&#125;</span><br><span class="line">反例：try &#123; obj.method(); &#125; catch(NullPointerException e)&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>异常被捕获后不要用来做流程控制和条件控制。</p>
</li>
<li><p>catch时请分清稳定代码和非稳定代码。稳定代码一般指本机运行且执行结果确定性高的代码。对于非稳定代码的catch，尽可能在进行异常类型的区分后，再做对应的异常处理。</p>
<p><strong>说明：对大段代码进行try-catch，将使程序无法根据不同的异常做出正确的“应激”反应，也不利于定位问题，这是一种不负责任的表现。</strong></p>
<blockquote>
<h5 id="（1）稳定代码示例"><a href="#（1）稳定代码示例" class="headerlink" title="（1）稳定代码示例"></a>（1）稳定代码示例</h5><p>稳定代码通常指在本机运行且执行结果确定性高的代码，例如简单的数学运算或确定性的数据处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 稳定代码示例 - 简单的数学计算</span><br><span class="line">public int calculateCircleArea(int radius) &#123;</span><br><span class="line">    // 这是一个确定性很高的计算</span><br><span class="line">    return (int)(Math.PI * radius * radius);</span><br><span class="line">&#125;</span><br><span class="line">// 调用稳定代码时，通常不需要try-catch</span><br><span class="line">public void useStableCode() &#123;</span><br><span class="line">    int radius = 5;</span><br><span class="line">    int area = calculateCircleArea(radius);</span><br><span class="line">    System.out.println(&quot;Area: &quot; + area);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这种稳定代码，不需要使用try-catch，因为：</p>
<ol>
<li>所有操作都是确定性的</li>
<li>不会抛出意外异常</li>
<li>参数类型和范围可以通过前置条件检查</li>
</ol>
<h5 id="（2）非稳定代码示例"><a href="#（2）非稳定代码示例" class="headerlink" title="（2）非稳定代码示例"></a>（2）非稳定代码示例</h5><p>非稳定代码通常涉及外部依赖或不确定因素，如网络请求、文件IO、数据库操作等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 非稳定代码示例 - 从网络获取数据</span><br><span class="line">public String fetchDataFromAPI(String url) throws IOException, APIException &#123;</span><br><span class="line">    // 这里可能有多种异常情况</span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">            .uri(URI.create(url))</span><br><span class="line">            .build();</span><br><span class="line">    HttpResponse&lt;String&gt; response = HttpClient.newHttpClient()</span><br><span class="line">            .send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">    if (response.statusCode() != 200) &#123;</span><br><span class="line">        throw new APIException(&quot;API returned status: &quot; + response.statusCode());</span><br><span class="line">    &#125;</span><br><span class="line">    return response.body();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用非稳定代码时，应该区分处理不同异常</span><br><span class="line">public void useUnstableCode() &#123;</span><br><span class="line">    String apiUrl = &quot;https://api.example.com/data&quot;;</span><br><span class="line">    try &#123;</span><br><span class="line">        String data = fetchDataFromAPI(apiUrl);</span><br><span class="line">        processData(data);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        // 处理网络或IO相关异常</span><br><span class="line">        System.err.println(&quot;Network error: &quot; + e.getMessage());</span><br><span class="line">        // 可能的恢复操作，如重试或使用缓存</span><br><span class="line">    &#125; catch (APIException e) &#123;</span><br><span class="line">        // 处理API特定的业务异常</span><br><span class="line">        System.err.println(&quot;API error: &quot; + e.getMessage());</span><br><span class="line">        // 可能的恢复操作，如使用备用API</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        // 捕获其他未预期的异常</span><br><span class="line">        System.err.println(&quot;Unexpected error: &quot; + e.getMessage());</span><br><span class="line">        // 记录日志并优雅降级</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非稳定代码，应该：</p>
<ol>
<li>区分不同类型的异常</li>
<li>为每种异常提供适当的处理或恢复策略</li>
<li>避免笼统的捕获所有异常</li>
<li>在最外层提供适当的错误反馈机制</li>
</ol>
<h5 id="（3）不良实践示例（应避免）"><a href="#（3）不良实践示例（应避免）" class="headerlink" title="（3）不良实践示例（应避免）"></a>（3）不良实践示例（应避免）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 不好的做法 - 大段代码笼统try-catch</span><br><span class="line">public void badPractice() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 包含多种操作的代码块</span><br><span class="line">        String data = fetchDataFromAPI(&quot;https://api.example.com/data&quot;);</span><br><span class="line">        processData(data);</span><br><span class="line">        saveToDatabase(data);</span><br><span class="line">        sendNotification();</span><br><span class="line">    &#125; catch (Exception e) &#123; // 捕获所有异常</span><br><span class="line">        System.out.println(&quot;Something went wrong&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法的缺点：</p>
<ol>
<li>无法区分不同类型的错误</li>
<li>无法针对特定错误采取特定恢复措施</li>
<li>不利于问题定位和调试</li>
<li>用户体验差（只有笼统的错误信息）</li>
</ol>
</blockquote>
</li>
<li><p>捕获异常是为了处理异常，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者必须处理异常，将其转化为用户可以理解的内容。</p>
</li>
<li><p>finally块必须对资源对象、流对象进行关闭操作，如果有异常就要做try-catch操作。</p>
<p><strong>说明：</strong>对于JDK 7及以上版本，可以使用try-with-resources方式。</p>
</li>
<li><p>不要在finally块中使用return。</p>
<p><strong>说明：</strong>try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情地丢弃try块中的返回点。</p>
</li>
<li><p>捕获异常与抛异常必须完全匹配，或者捕获异常是抛异常的父类。</p>
<p><strong>说明：</strong>如果预计对方抛的是绣球，实际接到的是铅球，就会产生意外。</p>
</li>
<li><p><strong>防止产生NPE是程序员的基本修养，</strong>注意NPE产生的场景。</p>
<p><strong>说明：</strong>本手册明确，防止产生NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null值的情况。</p>
<p>1）当返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。</p>
<p><strong>反例：</strong>public int f() { return Integer对象}， 如果为null，则自动拆箱，抛NPE。</p>
<p>2）数据库的查询结果可能为null。</p>
<p>3）集合里的元素即使isNotEmpty，取出的数据元素也可能为null。</p>
<p>4）当远程调用返回对象时，一律要求进行空指针判断，以防止产生NPE。</p>
<p>5）对于Session中获取的数据，建议进行NPE检查，以避免空指针。</p>
<p>6）级联调用obj.getA().getB().getC()；的一连串调用，易产生NPE。</p>
<p><strong>正例：</strong>使用JDK 8的Optional类防止产生NPE。</p>
</li>
<li><p>定义时区分unchecked &#x2F; checked异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException &#x2F; ServiceException等。</p>
</li>
</ol>
<h3 id="2-3-日志规约"><a href="#2-3-日志规约" class="headerlink" title="2.3　日志规约"></a>2.3　日志规约</h3><ol>
<li><p>应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架（SLF4J、JCL–Jakarta Commons Logging）中的API，使用门面模式的日志框架，有利于维护日志并保证各个类的日志处理方式统一。</p>
</li>
<li><p>所有日志文件至少保存15天，因为有些异常具备以“周”为频次发生的特点。对于当天日志，以“应用名.log”保存在“&#x2F;home&#x2F;admin&#x2F;应用名&#x2F;logs&#x2F;”目录下，过往日志格式： {logname}.log.{保存日期}，日期格式：yyyy-MM-dd。</p>
</li>
<li><p>应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType为日志类型，如stats&#x2F;monitor&#x2F;access等；logName为日志描述。这种命名的好处是通过文件名就可以知道日志文件属于哪个应用，哪种类型，有什么目的，这也有利于归类查找。</p>
<p><strong>说明：</strong>推荐对日志进行分类，如将错误日志和业务日志分开存放，既便于开发人员查看，也便于通过日志及时监控系统。</p>
<p>下面是一个完整的基于SLF4J+Logback实现错误日志和业务日志分离的示例，包含配置和代码实现。</p>
<blockquote>
<h5 id="1-Maven依赖配置"><a href="#1-Maven依赖配置" class="headerlink" title="1. Maven依赖配置"></a>1. Maven依赖配置</h5><p>首先确保pom.xml中包含必要的依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- SLF4J API --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.7&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- Logback实现 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.4.7&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-Logback配置文件-logback-xml"><a href="#2-Logback配置文件-logback-xml" class="headerlink" title="2. Logback配置文件 (logback.xml)"></a>2. Logback配置文件 (logback.xml)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 定义日志存储目录 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;LOG_DIR&quot;</span> value=<span class="string">&quot;./logs&quot;</span> /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 公共日志格式 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;COMMON_PATTERN&quot;</span> </span><br><span class="line">              value=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot;</span> /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 业务日志Appender --&gt;</span><br><span class="line">    &lt;appender name=<span class="string">&quot;BUSINESS&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br><span class="line">        &lt;file&gt;$&#123;LOG_DIR&#125;/business.log&lt;/file&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;$&#123;COMMON_PATTERN&#125;&lt;/pattern&gt;</span><br><span class="line">            &lt;charset&gt;UTF-<span class="number">8</span>&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">        &lt;rollingPolicy class=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;LOG_DIR&#125;/business.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;maxHistory&gt;<span class="number">30</span>&lt;/maxHistory&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 错误日志Appender --&gt;</span><br><span class="line">    &lt;appender name=<span class="string">&quot;ERROR&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br><span class="line">        &lt;file&gt;$&#123;LOG_DIR&#125;/error.log&lt;/file&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;$&#123;COMMON_PATTERN&#125;&lt;/pattern&gt;</span><br><span class="line">            &lt;charset&gt;UTF-<span class="number">8</span>&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">        &lt;filter class=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span><br><span class="line">            &lt;level&gt;ERROR&lt;/level&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">        &lt;rollingPolicy class=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;LOG_DIR&#125;/error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;maxHistory&gt;<span class="number">90</span>&lt;/maxHistory&gt; &lt;!-- 错误日志保留更久 --&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 业务日志Logger配置 --&gt;</span><br><span class="line">    &lt;logger name=<span class="string">&quot;com.example.business&quot;</span> level=<span class="string">&quot;INFO&quot;</span> additivity=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;BUSINESS&quot;</span> /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 系统错误日志配置 --&gt;</span><br><span class="line">    &lt;root level=<span class="string">&quot;ERROR&quot;</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;ERROR&quot;</span> /&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-Java代码实现示例"><a href="#3-Java代码实现示例" class="headerlink" title="3. Java代码实现示例"></a>3. Java代码实现示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">// 业务日志Logger - 使用特定包名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">businessLogger</span> <span class="operator">=</span> </span><br><span class="line">            LoggerFactory.getLogger(<span class="string">&quot;com.example.business.OrderService&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 错误日志Logger - 使用类名(会被root logger捕获)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">errorLogger</span> <span class="operator">=</span> </span><br><span class="line">            LoggerFactory.getLogger(OrderService.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务日志记录</span></span><br><span class="line">            businessLogger.info(<span class="string">&quot;开始处理订单, 订单ID: &#123;&#125;&quot;</span>, order.getId());</span><br><span class="line">            businessLogger.debug(<span class="string">&quot;订单详情: &#123;&#125;&quot;</span>, order.toString());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 业务逻辑处理...</span></span><br><span class="line">            </span><br><span class="line">            businessLogger.info(<span class="string">&quot;订单处理完成, 订单ID: &#123;&#125;&quot;</span>, order.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 错误日志记录</span></span><br><span class="line">            errorLogger.error(<span class="string">&quot;处理订单异常, 订单ID: &quot;</span> + order.getId(), e);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 同时也可以在业务日志中记录错误(可选)</span></span><br><span class="line">            businessLogger.warn(<span class="string">&quot;订单处理失败, 订单ID: &#123;&#125;, 原因: &#123;&#125;&quot;</span>, </span><br><span class="line">                    order.getId(), e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个服务示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="comment">// 业务日志Logger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">businessLogger</span> <span class="operator">=</span> </span><br><span class="line">            LoggerFactory.getLogger(<span class="string">&quot;com.example.business.PaymentService&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 错误日志Logger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">errorLogger</span> <span class="operator">=</span> </span><br><span class="line">            LoggerFactory.getLogger(PaymentService.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">(Payment payment)</span> &#123;</span><br><span class="line">        businessLogger.info(<span class="string">&quot;开始处理支付, 支付单号: &#123;&#125;&quot;</span>, payment.getTransactionId());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 支付处理逻辑...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (PaymentException e) &#123;</span><br><span class="line">            errorLogger.error(<span class="string">&quot;支付处理失败, 交易号: &#123;&#125;, 错误码: &#123;&#125;&quot;</span>, </span><br><span class="line">                    payment.getTransactionId(), e.getErrorCode(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-高级配置建议"><a href="#4-高级配置建议" class="headerlink" title="4. 高级配置建议"></a>4. 高级配置建议</h5><ol>
<li><strong>多环境配置</strong>：可以为不同环境(dev&#x2F;test&#x2F;prod)配置不同的日志级别和输出方式</li>
<li><strong>日志文件大小控制</strong>：可以添加SizeBasedTriggeringPolicy控制单个日志文件大小</li>
<li><strong>异步日志</strong>：对于高性能场景，可以使用AsyncAppender</li>
<li><strong>MDC应用</strong>：可以在业务日志中添加追踪ID等上下文信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 异步日志配置示例 --&gt;</span><br><span class="line">&lt;appender name=&quot;ASYNC_BUSINESS&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;</span><br><span class="line">    &lt;queueSize&gt;1024&lt;/queueSize&gt;</span><br><span class="line">    &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;BUSINESS&quot; /&gt;</span><br><span class="line">&lt;/appender&gt;</span><br></pre></td></tr></table></figure>

<p>这种分离方式使得：</p>
<ul>
<li>所有业务日志会记录到business.log文件中</li>
<li>所有ERROR级别日志会记录到error.log文件中</li>
<li>开发人员可以专注于查看业务日志</li>
<li>运维人员可以监控error.log快速发现问题</li>
</ul>
</blockquote>
</li>
<li><p>当输出日志时，字符串变量之间的拼接使用占位符的方式。</p>
<p><strong>说明：</strong>因为String字符串的拼接会使用StringBuilder的append()方式，所以有一定的性能损耗。<strong>使用占位符仅是替换动作，可以有效提升性能。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id : &#123;&#125; and symbol: &#123;&#125;&quot;</span>,id,symbol);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在生产环境中禁止直接使用System.out或System. err输出日志，或使用e.printStackTrace()打印异常堆栈。</p>
</li>
<li><p>异常信息应该包括两类：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logger.error(&quot;inputParams:&#123;&#125; and errorMessage: &#123;&#125;&quot;,各类参数或者对象.toString(), e,getMessage(),e)</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印日志时，禁止直接用JSON工具将对象转换成String。</p>
<p><strong>正例：</strong>打印日志时，仅打印业务相关属性值或者调用其对象的toString()方法。</p>
<p><strong>说明：</strong>如果对象里某些get方法被覆写，存在抛出异常的情况，则可能会因为打印日志而影响正常的业务流程的执行。</p>
</li>
<li><p><strong>谨慎地记录日志。在生产环境中禁止输出debug日志</strong>；<strong>有选择地输出info日志</strong>；如果使用warn记录刚上线时的业务行为信息，则一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并及时删除这些观察日志。</p>
<p><strong>说明：</strong>大量地输出无效日志，既不利于提升系统性能，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</p>
</li>
<li><p>可以使用warn日志级别记录用户输入参数错误的情况，避免当用户投诉时无所适从。</p>
<p><strong>说明：</strong>如非必要，请不要在此场景中打出error级别，避免频繁报警。注意日志输出的级别，<strong>error级别只记录系统逻辑出错、异常等重要的错误信息。</strong></p>
</li>
</ol>
<h2 id="第3章-单元测试"><a href="#第3章-单元测试" class="headerlink" title="第3章　单元测试"></a>第3章　单元测试</h2><p>什么是好的单元测试标准？如何写好单元测试？本章首次提出AIR原则和BCDE原则进行衡量。</p>
<ol>
<li><p><strong>单元测试应该是全自动执行的，并且是非交互式的。</strong>测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。需要人工检查输出结果的测试不是好的单元测试。单元测试中不准使用System.out进行人肉验证，必须使用assert验证。</p>
</li>
<li><p>保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</p>
<p><strong>反例：</strong>method2需要依赖method1的执行，将执行结果作为method2的输入。</p>
</li>
<li><p>对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单元测试粒度至多是类级别，一般是方法级别。</p>
<p><strong>说明：</strong>只有测试粒度足够小，才能在出错时尽快定位到出错位置。单元测试不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。</p>
</li>
<li><p>【重要】<strong>核心业务、核心应用、核心模块的增量代码确保通过单元测试。</strong></p>
<p><strong>说明：</strong>新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。</p>
</li>
<li><p>单元测试代码必须写在如下工程目录下：src&#x2F;test&#x2F; java，不允许写在业务代码目录下。</p>
<p><strong>说明：</strong>源码编译时会跳过此目录，而单元测试框架默认扫描此目录。</p>
</li>
<li><p>单元测试的基本目标：语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100%。</p>
<p><strong>说明：</strong>在工程规约的应用分层中提到的DAO层、Manager层、可重用度高的Service层，都应该进行单元测试。</p>
</li>
<li><p>编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。</p>
<ul>
<li>B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点和数据顺序等。</li>
<li>C：Correct，正确地输入，并得到预期的结果。</li>
<li>D：Design，与设计文档相结合，编写单元测试。</li>
<li>E：Error，强制错误信息输入（如：非法数据、异常流程、业务允许输入等），并得到预期的结果。</li>
</ul>
</li>
<li><p>和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。</p>
<p><strong>正例：</strong>在阿里云的内部单元测试中，使用ALIYUN_UNIT_TEST_的前缀来标识单元测试相关代码。</p>
</li>
<li><p>作为一种质量保障手段，不建议项目发布后补充单元测试用例，建议在项目提测前完成单元测试。</p>
</li>
<li><p>为了更方便地进行单元测试，业务代码应避免出现以下情况。</p>
<p>1）构造方法中做的事情过多。</p>
<p>2）存在过多的全局变量和静态方法。</p>
<p>3）存在过多的外部依赖。</p>
<p>4）存在过多的条件语句。</p>
<p><strong>说明：</strong>多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。</p>
</li>
<li><p>不要对单元测试存在如下<strong>误解</strong>：</p>
<p>1）<strong>那是测试工程师干的事情。</strong>本书是开发手册，凡是本书内容，都是与开发工程师强相关的。</p>
<p>2）单元测试代码是多余的。系统的整体功能与各单元部件的测试正常与否是强相关的。</p>
<p>3）单元测试代码不需要维护。如果不维护，那么一年半载后，单元测试几乎处于废弃状态。</p>
<p>4）单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。</p>
</li>
</ol>
<h2 id="第4章-安全规约"><a href="#第4章-安全规约" class="headerlink" title="第4章 安全规约"></a>第4章 安全规约</h2><p>“安全生产，责任重于泰山。”这句话同样适用于软件生产场景中，本章主要说明编程中需要注意的安全准则。</p>
<ol>
<li><p>隶属于用户个人的页面或者功能必须进行权限控制校验。</p>
<p><strong>说明：</strong>防止没有做水平权限校验就可以随意访问、修改、删除别人的数据，比如查看他人的私信内容。</p>
</li>
<li><p>用户敏感数据禁止直接展示，必须对展示数据进行脱敏。</p>
<p><strong>说明：</strong>个人手机号码显示为137****0969，隐藏中间4位，防止隐私泄露。</p>
</li>
<li><p>用户输入的SQL参数<strong>严格使用参数绑定或者METADATA字段值限定，防止SQL注入</strong>，禁止字符串拼接SQL访问数据库。</p>
<p><strong>反例：</strong>某系统没有对危险字符 # –进行转义，导致在更新数据库时，where后边的信息被注释掉，对全库进行了更新，从而造成大量系统签名被恶意修改。</p>
</li>
<li><p>用户请求<strong>传入的任何参数必须做有效性验证</strong>。</p>
<p><strong>说明：</strong>忽略参数校验可能导致如下情况。</p>
<p>1）page size过大导致内存溢出。</p>
<p>2）恶意order by导致数据库慢查询。</p>
<p>3）缓存击穿。</p>
<p>4）SSRF。</p>
<p>5）任意重定向。</p>
<p>6）SQL注入、Shell注入和反序列化注入。</p>
<p>7）正则输入源串拒绝服务ReDoS。</p>
<p>Java代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用特殊构造的字符串来验证，则有可能导致死循环。</p>
</li>
<li><p>在提交表单、AJAX时须执行CSRF安全验证。</p>
<p><strong>说明：</strong>CSRF(Cross-Site Request Forgery)跨站请求伪造是一类常见的编程漏洞。对于存在CSRF漏洞的应用或网站，攻击者可以事先构造好URL，一旦用户访问，后台便可在其不知情的情况下对数据库中的用户参数进行相应的修改。</p>
</li>
<li><p>URL外部重定向传入的目标地址必须执行白名单过滤。</p>
</li>
<li><p>在使用平台资源时，例如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷导致用户受扰或平台资损。</p>
<p><strong>说明：</strong>例如，注册时将验证码发送到手机，如果没有限制次数和频率，那么可以利用此功能骚扰其他用户，并造成短信平台资源浪费。</p>
</li>
<li><p>针对发帖、评论、发送即时消息等用户生成内容的场景，必须实行防刷、文本内容违禁词过滤等风控策略。</p>
</li>
</ol>
<h2 id="第5章-MySQL数据库"><a href="#第5章-MySQL数据库" class="headerlink" title="第5章　MySQL数据库"></a>第5章　MySQL数据库</h2><p>底层数据库的规范有助于降低软件实现的复杂度，降低沟通成本。本章主要说明建表规范、索引优化准则及ORM层的处理约定。ORM（Object-Relational Mapping）层是应用程序架构中负责处理<strong>对象与关系型数据库之间映射</strong>的组件层，它位于业务逻辑层和数据访问层之间。</p>
<blockquote>
<p><strong>ORM层的核心作用</strong>：</p>
<ol>
<li><strong>桥梁作用</strong>：将面向对象的编程语言与关系型数据库连接起来</li>
<li><strong>转换功能</strong>：实现数据库表记录↔编程语言对象的双向转换</li>
<li><strong>抽象封装</strong>：隐藏底层SQL操作细节，提供面向对象的数据库访问接口</li>
</ol>
<p><strong>优势</strong>：</p>
<ul>
<li>提高开发效率，减少重复SQL编写</li>
<li>使代码更面向对象，提高可维护性</li>
<li>提供跨数据库支持（通过方言机制）</li>
<li>内置安全机制防止SQL注入</li>
</ul>
<p><strong>局限</strong>：</p>
<ul>
<li>学习曲线较陡峭</li>
<li>复杂查询可能性能不如手写SQL</li>
<li>过度抽象可能导致调试困难</li>
<li>不合理的映射设计可能引发N+1查询问题</li>
</ul>
<p><strong>ORM层工作流程示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 定义实体类（对象-表映射）</span><br><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;employees&quot;)</span><br><span class="line">public class Employee &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line">    </span><br><span class="line">    @Column(name = &quot;emp_name&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    // 关联部门（关系映射）</span><br><span class="line">    @ManyToOne</span><br><span class="line">    @JoinColumn(name = &quot;dept_id&quot;)</span><br><span class="line">    private Department department;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. ORM操作示例</span><br><span class="line">public class EmployeeService &#123;</span><br><span class="line">    public void updateEmployeeDepartment(Long empId, Long deptId) &#123;</span><br><span class="line">        // 开启事务（ORM事务管理）</span><br><span class="line">        Transaction tx = session.beginTransaction();</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            // 查询员工（自动生成SELECT语句）</span><br><span class="line">            Employee emp = session.get(Employee.class, empId);</span><br><span class="line">            </span><br><span class="line">            // 查询部门</span><br><span class="line">            Department dept = session.get(Department.class, deptId);</span><br><span class="line">            </span><br><span class="line">            // 更新关联（自动处理外键关系）</span><br><span class="line">            emp.setDepartment(dept);</span><br><span class="line">            </span><br><span class="line">            // 提交事务（自动生成UPDATE语句）</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-1-建表规约"><a href="#5-1-建表规约" class="headerlink" title="5.1　建表规约"></a>5.1　建表规约</h3><ol>
<li><p>表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（1表示是，0表示否）。</p>
<p><strong>说明：</strong>任何字段如果为非负数，则必须是unsigned。</p>
<p><strong>注意：</strong>POJO类中的任何布尔类型的变量，都不要加is前缀，需要在<resultMap>中设置从is_xxx到xxx的映射关系。数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取值含义与取值范围。</p>
<p><strong>正例：</strong>表达逻辑删除的字段名is_deleted，1表示删除，0表示未删除。</p>
</li>
<li><p>【重要】<strong>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下画线中间只出现数字。</strong>数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p>
<p><strong>说明：</strong>MySQL在Windows系统中不区分大小写，但在Linux系统中默认区分大小写。因此，数据库名、表名和字段名，都不允许出现任何大写字母，避免节外生枝。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：aliyun_adminr，dc_config，level3_name</span><br><span class="line">反例：AliyunAdmin，rdcConfig，level_3_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>主键索引名为pk_字段名，唯一索引名为uk_字段名，普通索引名则为idx_字段名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明：pk_即primary key，uk_即unique key，idx_即index的简称。</span><br></pre></td></tr></table></figure>
</li>
<li><p>小数类型为decimal，禁止使用float和double类型。</p>
<p><strong>说明：</strong>在存储时，float和double类型存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过decimal的范围，那么建议将数据拆成整数和小数并分开存储。</p>
</li>
<li><p>如果存储的<strong>字符串长度几乎相等，则使用char定长字符串类型</strong>。</p>
</li>
<li><p><strong>varchar是可变长字符串，不预先分配存储空间，长度不要超过5000个字符</strong>，如果存储长度大于此值，则应定义字段类型为text，独立出来一张表，用主键来对应，避免影响其他字段的索引效率。</p>
</li>
<li><p>【重要】表必备三字段：id、create_time、update_time。</p>
<p><strong>说明：</strong>其中id必为主键，类型为bigint unsigned、单表时自增、步长为1。create_time和update_time的类型均为date_time。</p>
</li>
<li><p>表的命名最好遵循“业务名称_表的作用”原则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：alipay_task/force_project/trade_config</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字段允许适当冗余，以提高查询性能，但必须考虑数据一致性。</strong>冗余字段应遵循以下原则。</p>
<p>1）不是频繁修改的字段。</p>
<p>2）不是唯一索引的字段。</p>
<p>3）不是varchar超长字段，更不能是text字段。</p>
<p><strong>正例：</strong>各业务线经常冗余存储商品名称，避免查询时需要调用基础服务获取。</p>
</li>
</ol>
<h3 id="5-2-索引规约"><a href="#5-2-索引规约" class="headerlink" title="5.2　索引规约"></a>5.2　索引规约</h3><ol>
<li><p>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</p>
<p><strong>说明：</strong>不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但会明显提高查找速度；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，就必然有脏数据产生。</p>
</li>
<li><p>超过三个表禁止join。需要join的字段，数据类型必须绝对一致；当多表关联查询时，保证被关联的字段需要有索引。</p>
<p><strong>说明：</strong>即使双表join，也要注意表索引、SQL性能。</p>
</li>
<li><p>在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</p>
<p><strong>说明：</strong>索引的长度与区分度是一对矛盾体，一般对于字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度来确定。</p>
</li>
<li><p>利用覆盖索引进行查询操作，避免回表。</p>
<p><strong>说明：</strong>如果想知道一本书的第11章是什么标题，我们有必要翻开第11章对应的那一页吗？只要浏览一下目录就好，这个目录就起到覆盖索引的作用。</p>
<p><strong>正例：</strong>能够建立索引的种类分为主键索引、唯一索引、普通索引3种，而覆盖索引只是查询的一种效果，用explain的结果，extra列会出现“using index”。</p>
</li>
<li><p>利用延迟关联或者子查询优化超多分页场景。</p>
<p><strong>说明：</strong>MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行。当offset特别大的时候，效率会非常低，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。</p>
<blockquote>
<h5 id="问题背景理解"><a href="#问题背景理解" class="headerlink" title="问题背景理解"></a>问题背景理解</h5><p>MySQL的LIMIT分页机制在处理大数据量时存在性能问题，特别是当offset值很大时。这是因为MySQL的执行方式不是”跳过”offset行，而是”先取offset+N行，然后丢弃前offset行”。</p>
<h5 id="原始分页查询的问题"><a href="#原始分页查询的问题" class="headerlink" title="原始分页查询的问题"></a>原始分页查询的问题</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 传统分页查询（offset很大时性能差）</span><br><span class="line">SELECT * FROM large_table ORDER BY create_time DESC LIMIT 100000, 10;</span><br></pre></td></tr></table></figure>

<p>这个查询的执行过程：</p>
<ol>
<li>先读取100010行数据（即使你只需要10行）</li>
<li>然后丢弃前100000行</li>
<li>最后返回剩下的10行</li>
</ol>
<h5 id="优化方案一：延迟关联"><a href="#优化方案一：延迟关联" class="headerlink" title="优化方案一：延迟关联"></a>优化方案一：延迟关联</h5><h6 id="优化原理-先通过索引获取主键ID，然后再关联原表获取完整数据。"><a href="#优化原理-先通过索引获取主键ID，然后再关联原表获取完整数据。" class="headerlink" title="优化原理:先通过索引获取主键ID，然后再关联原表获取完整数据。"></a>优化原理:先通过索引获取主键ID，然后再关联原表获取完整数据。</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 优化后的延迟关联查询</span><br><span class="line">SELECT t.* FROM large_table t</span><br><span class="line">INNER JOIN (</span><br><span class="line">    SELECT id FROM large_table</span><br><span class="line">    ORDER BY create_time DESC</span><br><span class="line">    LIMIT 100000, 10</span><br><span class="line">) AS tmp ON t.id = tmp.id;</span><br></pre></td></tr></table></figure>

<p><strong>执行过程</strong>：</p>
<ol>
<li>子查询只查询ID（利用覆盖索引）</li>
<li>外层查询通过ID关联获取完整数据</li>
<li>大大减少了需要读取的数据量</li>
</ol>
<h5 id="优化方案二：子查询优化"><a href="#优化方案二：子查询优化" class="headerlink" title="优化方案二：子查询优化"></a>优化方案二：子查询优化</h5><h6 id="优化原理-利用主键或唯一索引的特性，先定位到起始位置，再获取后续记录。"><a href="#优化原理-利用主键或唯一索引的特性，先定位到起始位置，再获取后续记录。" class="headerlink" title="优化原理:利用主键或唯一索引的特性，先定位到起始位置，再获取后续记录。"></a>优化原理:利用主键或唯一索引的特性，先定位到起始位置，再获取后续记录。</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 子查询优化（假设id是自增主键）</span><br><span class="line">SELECT * FROM large_table</span><br><span class="line">WHERE id &gt;= (</span><br><span class="line">    SELECT id FROM large_table</span><br><span class="line">    ORDER BY create_time DESC</span><br><span class="line">    LIMIT 100000, 1</span><br><span class="line">)</span><br><span class="line">ORDER BY create_time DESC</span><br><span class="line">LIMIT 10;</span><br></pre></td></tr></table></figure>

<p><strong>执行过程</strong>：</p>
<ol>
<li>子查询快速定位到第100000条记录的ID</li>
<li>主查询从该ID开始获取10条记录</li>
<li>避免了扫描和丢弃大量记录</li>
</ol>
<h5 id="实际案例对比"><a href="#实际案例对比" class="headerlink" title="实际案例对比"></a>实际案例对比</h5><p>假设有一个1000万条记录的用户表：</p>
<h6 id="原始查询（性能差）"><a href="#原始查询（性能差）" class="headerlink" title="原始查询（性能差）"></a>原始查询（性能差）</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 执行时间：约2.5秒</span><br><span class="line">SELECT * FROM users ORDER BY register_time DESC LIMIT 999990, 10;</span><br></pre></td></tr></table></figure>

<h6 id="优化后的查询（性能好）"><a href="#优化后的查询（性能好）" class="headerlink" title="优化后的查询（性能好）"></a>优化后的查询（性能好）</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 执行时间：约0.1秒</span><br><span class="line">SELECT u.* FROM users u</span><br><span class="line">INNER JOIN (</span><br><span class="line">    SELECT user_id FROM users</span><br><span class="line">    ORDER BY register_time DESC</span><br><span class="line">    LIMIT 999990, 10</span><br><span class="line">) AS tmp ON u.user_id = tmp.user_id;</span><br></pre></td></tr></table></figure>

<h6 id="其他优化策略"><a href="#其他优化策略" class="headerlink" title="其他优化策略"></a>其他优化策略</h6><ol>
<li><p><strong>记录上次查询位置</strong>（适用于连续分页）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 记住上一页最后一条记录的register_time和id</span><br><span class="line">SELECT * FROM users </span><br><span class="line">WHERE register_time &lt;= &#x27;2023-05-20 15:30:00&#x27; AND user_id &lt; 12345</span><br><span class="line">ORDER BY register_time DESC, user_id DESC</span><br><span class="line">LIMIT 10;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用覆盖索引</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 确保排序字段和查询字段都在索引中</span><br><span class="line">ALTER TABLE users ADD INDEX idx_register_time_id (register_time, user_id);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>业务层面限制</strong>：</p>
<ul>
<li>限制用户只能查看前100页</li>
<li>提供更精确的筛选条件减少数据量</li>
</ul>
</li>
</ol>
<h6 id="为什么这些优化有效？"><a href="#为什么这些优化有效？" class="headerlink" title="为什么这些优化有效？"></a>为什么这些优化有效？</h6><ol>
<li><strong>减少数据扫描量</strong>：延迟关联和子查询都先通过索引获取少量数据</li>
<li><strong>避免全表扫描</strong>：利用了索引的有序性</li>
<li><strong>减少内存消耗</strong>：不需要在内存中存储大量临时数据</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="5-3-SQL语句"><a href="#5-3-SQL语句" class="headerlink" title="5.3　SQL语句"></a>5.3　SQL语句</h3><ol>
<li><p>不要使用count(列名)或count(常量)来替代count(<em>)，count(</em>)是SQL92定义的标准统计行数的语法，与数据库无关，与NULL和非NULL无关。</p>
<p><strong>说明：</strong>count(*)会统计值为NULL的行，而count(列名)不会统计此列值为NULL的行。</p>
</li>
<li><p>count(distinct column) 计算该列除NULL外的不重复行数。注意，count(distinct column1, column2)，如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。</p>
</li>
<li><p>当某一列的值全为NULL时，count(column)的返回结果为0，但sum(column)的返回结果为NULL，因此使用sum()时需注意避免NPE问题。</p>
<p><strong>正例：</strong>可以使用如下方式避免sum的NPE问题：SELECT IFNULL(SUM (column), 0) FROM table;</p>
</li>
<li><p>使用ISNULL()判断是否为NULL值。</p>
<p><strong>说明：</strong>NULL与任何值的直接比较都为NULL。在SQL语句中，如果在null前换行，则会降低可读性。select * from table where column1 is null and column3 is not null; 而ISNULL(column)是一个整体，简捷易懂。从性能数据上分析，ISNULL(column)的执行效率更高一些。</p>
</li>
<li><p>不得使用外键与级联，一切外键概念必须在应用层解决。</p>
<p><strong>说明：</strong>以学生和成绩的关系为例，学生表中的student_id是主键，成绩表中的student_id为外键。如果更新学生表中的student_id，则同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p>
</li>
<li><p>对于数据库中表记录的查询和变更，只要涉及多个表，就需要在列名前加表的别名（或表名）进行限定。</p>
<p><strong>说明：</strong>对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在，就会抛异常。</p>
</li>
<li><p>in操作能避免则避免，若实在避免不了，则需要仔细评估in后面的集合元素数量，控制在1000之内。</p>
</li>
<li><p>如果有国际化需要，那么所有的字符存储与表示，均以UTF-8编码，注意字符统计函数的区别。</p>
<p><strong>说明：</strong>SELECT LENGTH(“轻松工作”)；返回为12。</p>
<p>SELECT CHARACTER_LENGTH(“轻松工作”)；返回为4。</p>
<p>如果需要存储表情，那么选择utf8mb4进行存储，注意它与UTF-8编码的区别。</p>
</li>
</ol>
<h3 id="5-4-ORM映射"><a href="#5-4-ORM映射" class="headerlink" title="5.4　ORM映射"></a>5.4　ORM映射</h3><ol>
<li><p>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</p>
<p><strong>说明：</strong></p>
<p>1）增加查询分析器解析成本。</p>
<p>2）增减字段容易与resultMap配置不一致。</p>
<p>3）多余字段增加网络开销，尤其是text类型的字段。</p>
</li>
<li><p>POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。</p>
<p><strong>说明：</strong>参见POJO类及数据库字段定义规定，在sql.xml中必须增加映射。</p>
</li>
<li><p>【重要】不要用resultClass作为返回参数，即使所有类属性名与数据库字段一一对应，也需要定义<resultMap>；反过来，每个表也必然有一个<resultMap>与之对应。</p>
<p><strong>说明：配置映射关系，使字段与DO类解耦，方便维护。</strong></p>
</li>
<li><p>【重要】sql.xml配置参数使用：#{}，#param#，不要使用${}，此种方式容易出现SQL注入。</p>
</li>
<li><p>不允许直接将HashMap与Hashtable作为查询结果集的输出。</p>
<p><strong>反例：</strong>某工程师为避免写一个<resultMap>xxx &lt;&#x2F;result Map&gt;，直接使用HashTable接收数据库返回结果，结果由于数据库版本不一样，出现日常把bigint转成Long值，而线上把bigint解析成BigInteger的现象，导致线上出现问题。</p>
</li>
<li><p>@Transactional事务不要滥用。事务会影响数据库的QPS，另外，使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿和统计修正等。</p>
</li>
</ol>
<h2 id="第6章-工程结构"><a href="#第6章-工程结构" class="headerlink" title="第6章　工程结构"></a>第6章　工程结构</h2><p>应用分层的百花齐放，导致对于分层与领域模型的理解多样化，非常不利于团队合作。本章主要说明应用工程分层思想、二方库约定及基本的服务器知识。</p>
<h3 id="6-1-应用分层"><a href="#6-1-应用分层" class="headerlink" title="6.1　应用分层"></a>6.1　应用分层</h3><ol>
<li><p>根据业务架构实践，结合业界分层规范与流行技术框架分析，推荐分层结构如图6-1所示，默认上层依赖于下层，箭头关系表示可直接依赖，如：开放API层可以依赖于请求处理层（Web层），也可以直接依赖业务逻辑层（Service层），以此类推。</p>
<img src="/2025/03/20/EP20-alibaba-java-readnote/%E6%8E%A8%E8%8D%90%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.png" class="" title="推荐分层结构">

<p>1）开放API层：可直接封装Service接口暴露成HSF接口，通过Web封装成HTTP接口、网关控制层等。</p>
<p>2）终端显示层：各个端的模板渲染并执行显示层。当前主要是velocity渲染、JS渲染、JSP渲染和移动端展示层等。</p>
<p>3）请求处理层（Web层）：主要转发访问控制，校验各类基本参数，或者简单处理不复用的业务等。</p>
<p>4）业务逻辑层（Service层）：相对具体的业务逻辑服务层。</p>
<p>5）通用逻辑层（Manager层）：有如下特征。</p>
<ul>
<li>对第三方平台封装的层，预处理返回结果及转化异常信息，适配上层接口；</li>
<li>对Service层通用能力的下沉，如缓存方案、中间件通用处理；</li>
<li>与DAO层交互，对DAO的业务通用能力的封装。</li>
</ul>
<p>6）数据持久层（DAO层）：与底层MySQL、Oracle、HBase和OB进行数据交互。</p>
<p>7）第三方服务：包括其他部门RPC服务接口、基础平台、其他公司的HTTP接口，如淘宝开发平台、支付宝付款服务、高德地图服务等。</p>
<p>8）外部数据接口：外部（应用）数据存储服务提供的接口，多见于数据迁移场景中。</p>
</li>
<li><p>（分层异常处理规约）在DAO层，产生的异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e)方式，并throw new DAOException(e)，不需要打印日志。因为日志在Manager&#x2F;Service层，一定需要捕获并写到日志文件中去，如果同台服务器再写日志，则会降低性能和浪费存储。当Service层出现异常时，必须将出错日志记录到磁盘，尽可能带上参数信息，相当于保护案发现场。如果Manager层与Service层同机部署，则日志方式与DAO层处理一致；如果是单独部署，则采用与Service一致的处理方式。Web层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到该异常将导致页面无法正常渲染，应该直接跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层需要将异常处理成errorCode和errorMessage的方式返回。</p>
</li>
<li><p>分层领域模型规约。</p>
<p>1）DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。</p>
<p>2）DTO（Data Transfer Object）：数据传输对象，Service层或Manager层向外传输的对象。</p>
<p>3）BO（Business Object）：业务对象，可以由Service层输出的封装业务逻辑的对象。</p>
<p>4）Query：数据查询对象，各层接收上层的查询请求。注意，【强制】如果超过2个参数的查询封装，则禁止使用Map类传输。</p>
<p>5）VO（View Object）：显示层对象，通常是Web层向模板渲染引擎层传输的对象。</p>
</li>
</ol>
<h3 id="6-2-二方库依赖"><a href="#6-2-二方库依赖" class="headerlink" title="6.2　二方库依赖"></a>6.2　二方库依赖</h3><ol>
<li><p>定义GAV遵从以下规则：</p>
<p>1）GroupID格式：com.{公司&#x2F;BU }.业务线.[子业务线]，最多4级。</p>
<p><strong>说明：</strong>{公司&#x2F;BU}，例如：alibaba&#x2F;taobao&#x2F;tmall&#x2F;aliex press等BU一级；子业务线可选。</p>
<p>2）ArtifactID格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库进行查证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：doubao-client/fastjson-api/jstorm-tool</span><br></pre></td></tr></table></figure>
</li>
<li><p>二方库版本号命名方式：主版本号.次版本号.修订号。</p>
<p>1）主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。</p>
<p>2）次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。</p>
<p>3）修订号：保持完全兼容性，修复BUG、新增次要功能特性等。</p>
<p><strong>说明：</strong>注意起始版本号必须为：.0.0，而不是0.0.1。</p>
<p><strong>反例：</strong>仓库内某二方库版本号从1.0.0.0开始，一直默默“升级”到1.0.0.64，完全失去版本的语义信息。</p>
</li>
<li><p>二方库的新增或升级，保持除功能点外的其他jar包仲裁结果不变。如果有改变，则必须明确评估和验证。</p>
<p><strong>说明：</strong>在升级时，进行dependency:resolve前后信息比对，如果仲裁结果完全不一致，那么通过dependency:tree命令，找出差异点，进行<exclude>排除jar包。</p>
</li>
<li><p>二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的POJO对象。</p>
</li>
<li><p>依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。</p>
<p><strong>说明：</strong>依赖springframework-core、-context、-beans，它们都是同一个版本，可以定义一个变量来保存版本${spring.version}。定义依赖的时候，引用该版本。</p>
</li>
<li><p>禁止在子项目的pom依赖中出现相同的GroupId，相同的ArtifactId，但是不同的Version。</p>
<p><strong>说明：</strong>在本地调试时会使用各子项目指定的版本号，但是当合并成一个war时，只能有一个版本号出现在最后的lib目录中。可能会出现在线下调试时是正确的，发布到线上却出故障的问题。</p>
</li>
<li><p>所有pom文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在<dependencyManagement>语句块中。</p>
<p><strong>说明：</strong><dependencyManagement>里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version和scope都读取自父pom。而<dependencies>所有声明在主pom的<dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。</p>
</li>
</ol>
<h3 id="6-3-服务器"><a href="#6-3-服务器" class="headerlink" title="6.3　服务器"></a>6.3　服务器</h3><ol>
<li><p>高并发服务器建议调小TCP协议的time_wait超时时间。</p>
<p><strong>说明：</strong>操作系统默认240s后，才会关闭处于time_wait状态的连接。在高并发访问场景下，服务器端会因为处于time_wait的连接数过多，而无法建立新的连接，所以需要在服务器上调小此等待值。</p>
</li>
<li><p>调大服务器所支持的最大文件句柄数，即fd（全称：FileDescriptor）。</p>
<p><strong>说明：</strong>主流操作系统的设计是将TCP&#x2F;UDP连接采用与文件一样的方式管理，即一个连接对应一个fd。主流的Linux服务器默认支持最大的fd数量为1024，当并发连接数很大时，很容易因为fd不足而出现”open too many files”错误，导致新的连接无法建立。建议将Linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。</p>
</li>
</ol>
<h2 id="第7章-设计规约"><a href="#第7章-设计规约" class="headerlink" title="第7章　设计规约"></a>第7章　设计规约</h2><p>诚如序言所讲，程序员是天生的艺术家，软件设计能力就是考验“艺术家”成色的试金石。本章主要说明软件设计过程中UML设计准则及基本的架构理念。</p>
<ol>
<li><p>存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。</p>
<p><strong>说明：</strong>有缺陷的底层数据结构容易导致系统风险上升，可扩展性下降，重构成本也会因历史数据迁移和系统平滑过渡而陡然增加，所以对存储方案和数据结构需要认真地设计和评审。生产环境提交执行后，团队成员需要进行double check。</p>
<p><strong>正例：</strong>评审内容包括存储介质选型、表结构设计能否满足技术方案、存取性能和存储空间能否满足业务发展、表或字段之间的辩证关系、字段名称、字段类型、索引等；数据结构变更（如在原有表中新增字段）也需要评审通过后再上线。</p>
</li>
<li><p>在需求分析阶段，如果与系统交互的<strong>User超过1类</strong>，并且相关的User Case超过5个，那么使用<strong>用例图</strong>来表达结构化需求会更加清晰。</p>
</li>
<li><p>如果某个<strong>业务对象的状态超过3个</strong>，那么应使用<strong>状态图</strong>表达并且明确<strong>状态变化的各个触发条件</strong>。</p>
<p><strong>说明：</strong>状态图的核心是对象状态，首先明确对象有多少种状态，然后明确两两状态之间是否存在直接转换关系，再明确触发状态转换的条件是什么。</p>
<p><strong>正例：</strong>淘宝订单状态有已下单、待付款、已付款、待发货、已发货、已收货等。比如已下单与已收货这两种状态之间是不可能有直接转换关系的。</p>
</li>
<li><p>如果系统中某个功能的<strong>调用链路上的涉及对象超过3个</strong>，则使用<strong>时序图</strong>表达并且明确各调用环节的输入与输出。</p>
<p><strong>说明：</strong>时序图反映了一系列对象间的交互与协作关系，清晰立体地反映了系统的调用纵深链路。</p>
</li>
<li><p>如果系统中<strong>模型类超过5个</strong>，并且存在复杂的依赖关系，则应使用<strong>类图</strong>表达并且明确类之间的关系。</p>
<p><strong>说明：</strong>类图就像建筑领域的施工图，如果搭平房，可能不需要，但如果建造“蚂蚁Z空间”大楼，则肯定需要详细的施工图。</p>
</li>
<li><p>如果系统中<strong>超过2个对象之间存在协作</strong>关系，并且需要表示复杂的处理流程，则使用<strong>活动图</strong>来表示。</p>
<p><strong>说明：</strong>活动图是流程图的扩展，增加了能够体现协作关系的对象泳道，支持并发表示等。</p>
</li>
<li><p>需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。</p>
<p><strong>反例：</strong>用户在淘宝付款过程中，银行扣款成功，发送给用户扣款成功短信，但是在支付宝入款时由于断网演练产生异常，淘宝订单页面依然显示未付款，导致用户投诉。</p>
</li>
<li><p>类在设计与实现时要符合单一原则。</p>
<p><strong>说明：</strong>单一原则是最易理解却又最难实现的一条规则，随着系统演进，工程师很多时候会忘记类设计的初衷。</p>
</li>
<li><p>谨慎使用继承的方式进行扩展，优先使用聚合或组合的方式来实现。</p>
<p><strong>说明：</strong>若一定要使用继承，则必须符合里氏代换原则，此原则要求在父类能够出现的地方子类一定能够出现，比如“把钱交出来”中，美元、欧元、人民币等钱的子类都可以出现。</p>
</li>
<li><p>避免发生如下误解：敏捷开发&#x3D;讲故事+编码+发布。</p>
<p><strong>说明：</strong>敏捷开发是快速交付迭代可用的系统，省略多余的设计方案，摒弃传统的审批流程，但在核心或关键模块上，必须进行必要的设计和文档的沉淀。</p>
<p><strong>反例：</strong>为了确保业务快速发展，敏捷成了某团队产品经理催进度的借口，系统中均是勉强能运行但像面条一样的代码，可维护性和可扩展性极差，一年之后，不得不进行大规模重构，得不偿失。</p>
</li>
<li><p><strong>系统设计文档的主要目的是明确需求、理顺逻辑、后期维护，次要目的是指导编码。</strong></p>
<p><strong>说明：</strong>避免为了设计而设计，系统设计文档应有助于后期的系统维护和重构，所以设计结果需要进行分类归档保存。</p>
</li>
<li><p>设计的本质就是识别和表达系统难点。</p>
<p><strong>说明：</strong>识别和表达完全是两回事，很多人错误地认为只要识别到系统难点在哪里，表达只是自然而然的事情，但是大家在设计评审时经常出现语焉不详，甚至词不达意的情况。准确地表达系统难点需要具备如下能力：表达规则和表达工具的熟练性，抽象思维和总结能力的局限性，基础知识体系的完备性，深入浅出的生动表达力。</p>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>java开发</tag>
      </tags>
  </entry>
</search>
